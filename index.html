<!doctype html><html lang=pt><head><meta charset=utf-8><title>Stone OpenBank</title><meta name=generator content="Hugo 0.69.0"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=stylesheet href=https://stone-co.github.io/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://stone-co.github.io/plugins/themify-icons/themify-icons.css><link rel=stylesheet href=https://stone-co.github.io/plugins/highlight/hybrid.css><link rel=icon href=https://stone-co.github.io/images/favicon.png type=image/x-icon><link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700&display=swap" rel=stylesheet><style>:root{--primary-color:#14aa4b;--body-color:#f8f9fd;--text-color:#677481;--text-color-dark:#5a6872;--white-color:#ffffff;--light-color:#f4f4f9;--font-family:Montserrat}</style><link href=https://stone-co.github.io/css/style.min.css rel=stylesheet media=screen><script src=https://stone-co.github.io/plugins/jquery/jquery-1.12.4.js></script><script src=https://stone-co.github.io/plugins/jquery/jquery-ui.js></script><script src=https://stone-co.github.io/plugins/bootstrap/bootstrap.min.js></script><script src=https://stone-co.github.io/plugins/match-height/jquery.matchHeight-min.js></script><script src=https://stone-co.github.io/plugins/highlight/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></head><body><header class="banner overlay bg-cover" data-background=https://stone-co.github.io/grid.png><nav class="navbar navbar-expand-md navbar-dark"><div class=container><a class="navbar-brand px-2" href=/><img class=img-fluid src=https://stone-co.github.io/stonew.png alt="Stone OpenBank"></a>
<button class="navbar-toggler border-0" type=button data-toggle=collapse data-target=#navigation aria-controls=navigation aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse text-center" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class="nav-link text-dark" href=/></a></li><li class=nav-item><a class="nav-link text-dark" href=/referencia-da-api>Referência da API</a></li><li class=nav-item><a class="nav-link text-dark" href=/guias>Guias</a></li><li class=nav-item><a class="nav-link text-dark" href="https://app.pipefy.com/public/form/Qz4ptt_W?origem_do_lead=Formul%C3%A1rio%20comercial%20documenta%C3%A7%C3%A3o">Quero ser parceiro</a></li></ul></div></div></nav><div class="container section"><div class=row><div class="col-lg-8 text-center mx-auto"><h1 class="text-white mb-3">Stone OpenBank</h1><p class="text-white mb-4">Escreva o Banco do futuro. Uma linha de código por vez.</p><div class=position-relative><input id=search class=form-control placeholder=Search>
<i class="ti-search search-icon"></i><script>$(function(){var projects=[{value:"Conta Stone SDK",label:"<p>Sejam bem-vindos à documentação da Conta Stone SDK. Através da Conta Stone SDK é possível fazer o processo de abertura de conta e login no Stone OpenBank.\nIntrodução A Conta Stone SDK é o ponto de entrada para acesso às nossas SDKs de autenticação (Auth SDK), aprovação (Approver SDK) e verificação de KYC (Know your costumer)(Pegasus SDK). Segue abaixo um diagrama de como funciona a comunicação entre esses três atores.\n    Auth SDK - responsável por executar todo o processo de autenticação seguindo as diretrizes do oAuth2.\n  Approver SDK - realiza todo o processo de aprovação e rejeição de transações.\n  Pegasus SDK - SDK de KYC, responsável por capturar as informações da usuária que está realizando cadastro na conta.\n  Como integrar com a SDK Antes de começar a integração é necessário obter uma chave de acesso ao nosso repositório. Para obter esta chave, entre em contato com a gente.\nNo arquivo build.gradle do projeto, adicione a URL do repositório.\nmaven { url \x26quot;https:\/\/packagecloud.io\/priv\/${access-key}\/Stone\/stoneid\/maven2\x26quot;} Importe a dependência da Conta Stone SDK\nimplementation \x26amp;apos;co.stone:conta:${latest_version}\x26amp;apos; Sincronize o projeto e pronto! Já é possível utilizar a conta-stone-sdk.\nInicializando a SDK Uma vez que a dependência foi importada o passo seguinte da integração é inicializar a SDK no seu app, para isso é necessário especificar os parâmetros abaixo.\nContaStone.initialize( application = applicationContext, environment = Environment.Production, appInfo = AppInfo( name = \x26quot;Conta Stone Android\x26quot;, version = BuildConfig.VERSION_NAME, buildId = BuildConfig.BUILD_ID ), clientId = \x26quot;client_id\x26quot;, redirectUri = URI(\x26quot;br.com.stone.openbank.example:\/oauth2redirect\x26quot;), authFlowUIConfig = AuthFlowUIConfig(R.style.AppTheme), httpClientConfig = HttpClientConfig(interceptors = emptyList()), tokenKeyMasterUri = URI(\x26quot;android-keystore:\/\/my-app\x26quot;), userBlockedActions = UserBlockedIntentConfig( uriLogout = \x26quot;myapp:\/\/mobile.example.logout\x26quot;, uriChat = \x26quot;myapp:\/\/mobile.example.chat\x26quot; ) ) application: Trata-se da instância do Application do seu app.\nenvironment: Existem 3 ambientes para os quais a sdk pode apontar: Homolog, Sandbox e Production.\nappInfo: Informações referentes ao app como nome, versão e build.\nclient_id: Identificador fornecido pelo time de suporte OpenBank.\nredirect_uri: URL de redirecionamento para o app.\nauthFlowUIConfig: Com esta configuração é possível passar o tema da sua aplicação para a SDK. Assim, as cores principais do estilo do seu app serão aplicadas nas telas internas da SDK.\nhttpClientConfig: Trata-se de configurações HTTP customizadas, como interceptors, connectionTimeoutMs, readTimeoutMs, writeTimeoutMs, networkInterceptors.\ntokenKeyMasterUri: Uma URI para a chave-mestra no formato android-keystore:\/\/. Essa chave será utilizada para acessar o Keystore do android e salvar o token da usuária de forma segura.\nuserBlockedActions: Se uma determinada usuária errar a senha de 6 dígitos mais de x vezes, ela será temporariamente bloqueada. Neste momento será exibida uma tela com duas opções: acesso ao canal de relacionamento ou fazer logout. Ao escolher entre elas, a usuária é redirecionada de volta para o app, através dessas duas URIs.\nPara mais detalhes sobre como configurar deep link no seu app, clique aqui.\nAutenticação e verificação de KYC Para iniciar o fluxo é necessário seguir o método abaixo:\nfun startAuthAndVerificationFlowForResult( activity: Activity, requestCode: Int, request: AuthFlowRequest, params: VerificationParams ) O atributo request refere-se a informações customizadas para o login, como os scopes. Tais recursos estarão disponíveis para a usuária ao chamar algum dos endpoints do serviço. Já o loginHint salva o email da usuária e é usado para preencher o username na tela de login.\nO atributo params recebe comandos de dois tipos: o modo de inicialização, ou seja, a maneira como o fluxo deve ser iniciado; e o NotificationRegister, que contém o token do Firebase Cloud Message da usuária logada para que seja registrado no serviço de notificações. Os modos de inicialização que podem ser escolhidos são:\nStartingApp - Inicia todo o fluxo de autenticação e checkagem de KYC.\nAccountSelectionRequest - Exibe a tela de troca de conta e lida com a escolha da usuária.\nPushNotificationReceived - Deve ser iniciado ao receber uma notificação de abertura de conta referente ao processo de abertura de conta.\nNewAccountCreated - Chamado de verificação de pendência a cada conta aberta pelo app\/sistema.\nEste método executa os fluxos internos de autenticação e verificação de KYC. Quando o processo é finalizado, a conta-stone-sdk retorna um resultado que será tratado pelo app.\nLidando com o resultado da sdk Ao finalizar o fluxo de autenticação e verificação a SDK emite um resultado para o app informando o desfecho do fluxo. Segue abaixo um exemplo de como tratar o resultado emitido pela conta-stone-sdk e o que cada um significa:\noverride fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { AUTH_AND_VERIFICATION_RC -\x26amp;gt; { val result = contaStone.parseAuthAndVerificationResult(data) when (result) { is AuthAndVerificationResult.Ok -\x26amp;gt; toast(\x26quot;Success\x26quot;) is AuthAndVerificationResult.MissingData -\x26amp;gt; toast(\x26quot;Some error occur while reading data\x26quot;) is AuthAndVerificationResult.UserCancelled -\x26amp;gt; toast(\x26quot;User cancelled flow\x26quot;) is AuthAndVerificationResult.ReturnToPreviousScreen -\x26amp;gt; toast(\x26quot;Returned to the previous screen and was logged out\x26quot;) is AuthAndVerificationResult.UserLoggedOut -\x26amp;gt; toast(\x26quot;User logged out\x26quot;) is AuthAndVerificationResult.BlockedUser -\x26amp;gt; toast(\x26quot;This user is blocked\x26quot;) is AuthAndVerificationResult.Error -\x26amp;gt; toast(\x26quot;Some error occur during auth and check flow) } } } } Como fazer logout da usuária Como mencionado anteriormente, a conta-stone-sdk se comunica com a sdk de autenticação, que pode ser acessada pelo método contaStone.auth() e permite acesso aos métodos da interface da authSdk, como o método de logout. Confira abaixo um exemplo de como isso funciona:\ncontaStone.auth().logout { exception: AuthFlowException? -\x26amp;gt; exception?.let { toast(\x26quot; Success \x26quot;)} ?: toast(\x26quot;Erro during logout\x26quot;) } Quando a resposta é nula, o logout ocorreu com sucesso. Quando não, algum erro ocorreu durante o fluxo.\nCliente autenticado A authSDK é responsável por todo o processo de autenticação, incluindo a adição do token no header das chamadas até a api do Stone Openbank. Para realizar tudo isso, a SDK cria um client e adiciona um interceptor, o qual recupera o token do storage e o adiciona no header da chamada.\nEsse client possui certificate pinning com os certificados da api do Stone OpenBank e é possível acessá-lo chamando o método contaStone.auth().client(), o qual retorna um OkHttpClient e pode ser utilizado nas chamadas HTTP do seu app.\n</p>",url:"https:\/\/stone-co.github.io\/sdks\/conta-stone-sdk\/"},{value:"Integrando na Prática",label:"<p>Neste tutorial vamos ver como:\n Gerar o token de autenticação; Gerar o token e link de consentimento; Operar em contas que já concederam acesso à aplicação parceira.  Utilizaremos a linguagem Python na versão 3.7 para montar o token e a biblioteca PyJWT para assiná-lo.\nConheça suas ferramentas É importante ler a documentação das bibliotecas utilizadas. A biblioteca utilizada neste tutorial, PyJWT, tem uma dependência extra para alguns algoritmos específicos. É o caso do algoritmo que será utilizado, RS256, que tem dependência da biblioteca cryptography. Por conta disso, esta biblioteca também precisa ser instalada.\n 1. Conhecendo os dados Como resultado do cadastro da sua aplicação, você recebeu um ClientID. Além disso, nos forneceu uma chave pública e manteve em segredo uma chave privada. Agora vamos ver como utilizá-los na prática.\nPara montar os tokens, tenha em mãos o seu redirect_uri cadastrado, o seu ClientID e sua chave privada.\n2. Se preparando para gerar tokens Aqui vamos importar as bibliotecas que vamos utilizar e definir algumas constantes.\nimport jwt import time import requests MINUTE = 60 HOUR = 3600 CLIENT_ID = \x26#34;92b5f9aa-9552-45f4-86cb-c0331c9178a2\x26#34; REDIRECT_URI = \x26#34;https:\/\/myapplication.com\/consent_callback\x26#34; ACCOUNTS_URL = \x26#34;https:\/\/sandbox-accounts.openbank.stone.com.br\x26#34; API_URL = \x26#34;https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1\x26#34; Armazenamos a chave privada no arquivo private.pem e preparamos uma função para gerar o token. Essa função recebe um parâmetro com os claims e usa a chave privada para gerar e assinar o token.\nLembrando que se trata de um processo de criptografia assimétrica. Neste processo, a desenvolvedora assina o token com sua chave privada e a Stone utiliza a chave pública compartilhada com a gente para verificar que realmente foi a aplicação parceira quem gerou o token.\ndef generate_token(claims): with open(\x26#34;private.pem\x26#34;, \x26#34;r\x26#34;) as key_file: token = jwt.encode(claims, key_file.read(), algorithm=\x26#39;RS256\x26#39;) return token.decode() Agora podemos assinar qualquer conjunto de claims e o resultado será um JWT. É possível utilizar claims arbitrários para testar essa funcionalidade:\n\x26gt;\x26gt;\x26gt; generate_token({\x26#34;claim\x26#34;: \x26#34;qualquer\x26#34;}) \x26#39;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJjbGFpbSI6InF1YWxxdWVyIn0.hUGnpB5pI38TbQy8XDjXMmFTLWvYjk98UaTELfkJmHU0EK9-ZOTzSSNKdqOB0puGHr2xMRXta6WZLQmkRqJCVHSA6zsIdW0ABJiPaHXVOHFidq7iGZAbZtgHBf6b3ctko7OGxfLDJGedH3gYVh9i_tJ3S0kWpvLS7yMqNgwyHI4ZJecmL-qYD30FgrhGqyMK3LCxId7O_T6_QOisaLe_XXstXUnm82qvDh7iMZPqhV39V_CxnLl6CVZp2IfdQ3i8LAmtqaxhYSTODwBj47zOm_4bhfOcMO91LxY3wWW8fU7Qr8hyiUHqayBTiLRYqEGet_esQ_rrVFOn0F3tU0eWSA\x26#39; Se chegou a este mesmo resultado, você tem uma função que pode ser utilizada para assinar qualquer um dos seus tokens.\nA biblioteca escolhida incluiu automaticamente no header as informações de tipo e algorítimo utilizados para gerar o token. Para se certificar da validade do token é possível utilizar o site jwt.io.\nObserve que trabalhamos com vários tokens JWT diferentes e utilizamos claims diferentes de acordo com a finalidade do token.\nPara o token de autenticação, é preciso utilizar os claims descritos em Autenticação; para o token de consentimento, serão utilizados os claims descritos em Consentimento.\n3. Montando o token de autenticação Inicialmente, é preciso consultar quais os claims específicos do token de autenticação na documentação.\nAtravés da função que construimos é possível gerar e assinar esse token de forma simples.\nEsse token será enviado para a Stone através de uma chamada para nosso servidor de autenticação, e enviaremos como resposta um access_token.\nO access_token também é do tipo JWT, e funciona como uma chave de acesso para todas requisições na API.\ndef auth_claims(): now = int(time.time()) return { \x26#34;aud\x26#34;: f\x26#34;{ACCOUNTS_URL}\/auth\/realms\/stone_bank\x26#34;, \x26#34;clientId\x26#34;: CLIENT_ID, \x26#34;exp\x26#34;: now \x2b 5 * MINUTE, \x26#34;iat\x26#34;: now, \x26#34;jti\x26#34;: f\x26#39;token_id:{str(time.time())}\x26#39;, \x26#34;nbf\x26#34;: now, \x26#34;realm\x26#34;: \x26#34;stone_bank\x26#34;, \x26#34;sub\x26#34;: CLIENT_ID, } def authenticate(): auth_token = generate_token(auth_claims()) data = { \x26#34;client_assertion_type\x26#34;: \x26#34;urn:ietf:params:oauth:client-assertion-type:jwt-bearer\x26#34;, \x26#34;client_assertion\x26#34;: auth_token, \x26#34;client_id\x26#34;: CLIENT_ID, \x26#34;grant_type\x26#34;: \x26#34;client_credentials\x26#34;, } response = requests.post( f\x26#34;{ACCOUNTS_URL}\/auth\/realms\/stone_bank\/protocol\/openid-connect\/token\x26#34;, data=data) return response.json()[\x26#34;access_token\x26#34;] Neste exemplo, estamos definindo uma função que retorna um dicionário com todos os claims necessários para o token de autenticação. Em seguida, é preciso enviar esse token e mais algumas informações para o nosso serviço de autenticação via POST.\nA biblioteca requests foi a escolhida para realizar as requisições HTTP. No parâmetro data, envia-se dados no formato \x26ldquo;x-www-form-urlencoded\x26rdquo; já que este é o formato esperado pelo servidor de autenticação. Ver documentação.\nNo parâmetro params envia-se os dados no formato Query String, e no parâmetro headers informamos o que será enviado no cabeçalho da requisição.\nPara facilitar o acesso aos dados da resposta, convertemos o conteúdo para JSON e retornamos o access_token.\nPara utilizar o token de acesso, é preciso apenas adicionar esse token em um cabeçalho authorization com o valor Bearer TOKEN. Com isso, já é possível operar na API como é demonstrado mais a frente.\n4. Montando o link de consentimento Assim como para o token de autenticação, inicialmente consultamos quais os claims específicos do token de consentimento na documentação e, em seguida, utilizamos a função que construimos para gerar e assinar o token.\nNeste caso, vamos um pouco além da geração do token, utilizando uma função para montar o link de consentimento com os três parâmetros especificados na documentação.\nResumindo o passo a passo para obter o link do consentimento, é preciso:\n Montar os claims para o token; Criar o token; Montar o link.  def consent_claims(): now = int(time.time()) return { \x26#34;aud\x26#34;: \x26#34;accounts-hubid@openbank.stone.com.br\x26#34;, \x26#34;client_id\x26#34;: CLIENT_ID, \x26#34;exp\x26#34;: now \x2b 2 * HOUR, \x26#34;iat\x26#34;: now, \x26#34;iss\x26#34;: CLIENT_ID, \x26#34;jti\x26#34;: str(time.time()), \x26#34;nbf\x26#34;: now, \x26#34;redirect_uri\x26#34;: REDIRECT_URI, \x26#34;session_metadata\x26#34;: {\x26#34;sid\x26#34;: f\x26#39;key:{time.time()}\x26#39;}, \x26#34;type\x26#34;: \x26#34;consent\x26#34;, } def consent_token(): return generate_token(consent_claims()) def consent_link(): return f\x26#34;{ACCOUNTS_URL}\/#\/consent?type=consent\x26amp;client_id={CLIENT_ID}\x26amp;jwt={consent_token()}\x26#34; O resultado será um link válido por duas horas. Ele pode ser acessado e testado através do navegador.\nObserve que alguns detalhes podem ser adaptados de acordo com as necessidades específiicas de controle de tokens da sua aplicação.\nUm exemplo é parâmetro jti, que faz parte dos claims e atua como um identificador do token. No código acima, é utilizada apenas uma string com o timestamp do momento como forma de garantir sua unicidade. Para sua aplicação é possível utilizar outros valores de forma a facilitar a identificação do token.\nOutro exemplo é o campo session_metadata, para o qual passamos um dicionário único apenas por ser um campo obrigatório. Neste caso não temos intenção de controlar a sessão, mas a desenvolvedora pode utilizá-lo para esta finalidade, passando valores que se encaixam nas suas necessiades.\n5. Utilizando a API Utilizando seu access_token já é possível acessar as funcionalidades da API, de acordo com o que a sua aplicação tem permissão de fazer. Para ter permissão de criar transações em contas de usuários, ou até de visualizar seus dados, é preciso obter consentimento do dono da conta. Isso é possível enviando o link construído no passo anterior para a usuária, para que ela possa dar acesso à conta.\nConsultando as contas às quais a aplicação parceira tem acesso Através da API é possível, por exemplo, consultar a quais contas você tem acesso, tanto no caso de você ser uma aplicação parceira com consentimento para acessar contas, quanto no caso de você ser proprietário de alguma conta.\nPara isso, é preciso apenas consultar o endpoint Consultar Todas Contas às Quais Se Tem Acesso, utilizando seu access_token no campo do botão Try It.\nOutra forma de acessar esse endpoint é realizando uma chamada para nossa API, enviando seu access_token em um header. Abaixo podemos observar isso em um exemplo de função que poderia ser utilizada para realizar essa consulta.\ndef operational_accounts(access_token, pagination_params={}): url = f\x26#34;{API_URL}\/accounts\x26#34; params = {\x26#34;paginate\x26#34;: \x26#34;true\x26#34;, **pagination_params} response = requests.get( url, params=params, headers={\x26#34;authorization\x26#34;: f\x26#39;Bearer {access_token}\x26#39;} ).json() return response[\x26#39;data\x26#39;] Analisando o código acima, podemos chegar às seguintes conclusões:\nObserve que temos dois parâmetros na função operational_accounts: access_token e pagination_params.\n  access_token : É o resultado de uma autenticação bem sucedida. Sempre que uma aplicação parceira se autenticar receberá um token de acesso, cuja validade é informada em seus claims;\n  pagination_params: A maior parte dos nossos endpoints utilizam uma paginação padrão. Isso permite realizar requisições HTTP de forma mais prática, além de poupar consumo de rede.\n  E, por fim, obtem-se como resposta uma lista das contas às quais a aplicação tem acesso.\nPadrões da Nossa API Seguimos alguns padrões para alguns tipos de dados em toda a nossa API. Aqui se encontram alguns destes padrões.\n Criando transferências em uma conta Outra funcionalidade é a criação de transferências, tanto entre contas Stone como também de uma conta Stone para contas em outros bancos.\nAssim como no caso anterior e de forma padrão para nossos endpoints, para acessá-los é preciso apenas obter permissão de acesso através do consentimento ou ser a própria dona da conta, e provar isso enviando seu access_token em um header. As informações de permissões de um sujeito são armazenadas em seu access_token.\nO exemplo a seguir foi construído considerando uma aplicação com acesso a pelo menos duas contas, e que a primeira conta tem saldo suficiente para a transferência.\ndef internal_transfer(token, params): url = f\x26#39;{API_URL}\/internal_transfers\x26#39; response = requests.post(url, json=params, headers={ \x26#34;authorization\x26#34;: f\x26#39;Bearer {token}\x26#39; }).json() return response token = authenticate() accounts = operational_accounts(token) internal_transfer_params = { \x26#34;amount\x26#34;: 1000, \x26#34;account_id\x26#34;: accounts[0][\x26#34;id\x26#34;], \x26#34;target\x26#34;: { \x26#34;account\x26#34;: {\x26#34;account_code\x26#34;: accounts[1][\x26#34;account_code\x26#34;]} } } response = internal_transfer(token, internal_transfer_params) print(response.json()) Ocorrendo tudo bem, você receberá como retorno as informações da transferência recém-criada. Em caso de erro como, por exemplo, por saldo insuficiente, receberá como retorno uma mensagem de erro.\nSucesso { \x26quot;amount\x26quot;: 1000, \x26quot;approval_expired_at\x26quot;: null, \x26quot;approved_at\x26quot;: null, \x26quot;approved_by\x26quot;: null, \x26quot;cancelled_at\x26quot;: null, \x26quot;created_at\x26quot;: \x26quot;2019-07-29T13:40:05Z\x26quot;, \x26quot;created_by\x26quot;: \x26quot;application:92b5f9aa-9552-45f4-86cb-c0331c9178a2\x26quot;, \x26quot;description\x26quot;: \x26quot;\x26quot;, \x26quot;failed_at\x26quot;: null, \x26quot;failure_reason_code\x26quot;: null, \x26quot;failure_reason_description\x26quot;: null, \x26quot;fee\x26quot;: 0, \x26quot;finished_at\x26quot;: null, \x26quot;id\x26quot;: \x26quot;000ebdf8-4acf-4ed2-83e9-f0c7a766ac61\x26quot;, \x26quot;rejected_at\x26quot;: null, \x26quot;rejected_by\x26quot;: null, \x26quot;scheduled_to\x26quot;: null, \x26quot;settled_at\x26quot;: null, \x26quot;status\x26quot;: \x26quot;CREATED\x26quot;, \x26quot;target\x26quot;: { \x26quot;account\x26quot;: { \x26quot;account_code\x26quot;: \x26quot;517532\x26quot; }, \x26quot;entity\x26quot;: { \x26quot;name\x26quot;: \x26quot;Severo\x26quot; } }, \x26quot;target_account_code\x26quot;: \x26quot;517532\x26quot;, \x26quot;target_account_owner_name\x26quot;: \x26quot;Severo\x26quot; } Failure {\x26quot;type\x26quot;: \x26quot;srn:error:not_enough_funds\x26quot;} Conclusão Utilizando tokens é possível se autenticar e realizar a solicitação de consentimento em contas de usuárias de forma segura.\nÉ preciso utilizar uma biblioteca para gerar e assinar os tokens JWT. A escolha da biblioteca deve ser feita com cuidado pois é preciso ter conhecimento de como utilizá-la corretamente para obter sucesso gerando os tokens.\nÉ interessante também consultar os claims específicos para cada token na sessão adequada da documentação, além de se atentar à necessidade de utilizar sua chave privada e o algoritmo RS256 para assinar seus tokens.\nUtilizando o access_token e obtendo consentimento, já é possível realizar chamadas na API e acessar suas funcionalidades, como consultar as contas às quais a aplicação tem acesso, consultar o saldo dessas contas e criar transferências.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/tutoriais\/integrando-na-pratica\/"},{value:"Boas Práticas",label:"<p>Tokens JWT Tokens JWT são dados sensíveis, assim como senhas ou dados de cartões de crédito. Por isso, é de extrema importância manusear e armazenar esses dados corretamente.\nNão armazene tokens no local storage O armazenamento local de um Browser não é um lugar seguro para se armazenar dados sensíveis. Dados armazenados no local storage podem:\n Ser acessados via Javascript; Ser vulneráveis a Cross-Site Scripting.  Caso um backend esteja disponível Se sua Aplicação tem um backend disponível, os tokens devem ser manuseados server-side.\nCaso um backend não esteja disponível Se sua Aplicação é uma Single Page Application, a Aplicação deve requisitar os tokens e armazená-los em memória sem nenhuma persistência. Faça as chamadas de API usando os tokens armazenados em memória.\nPara outros casos, informações sobre boas práticas com Tokens JWT estão disponíveis aqui.\nIdempotência Nossos endpoints que envolvem operações financeiras suportam Idempotência. Existe a possibilidade de ocorrer operações duplicadas, como, por exemplo, com a queda de conexão 3G durante a realização de uma operação. Para evitar que a mesma operação ocorra mais de uma vez no nosso sistema, sempre envie o cabeçalho de Idempotência (x-stone-idempotency-key).\nObserve abaixo cada caso possível em relação à chave de idempotência e seus retornos:\n Uma chamada com outra chave de idempotência, independente do corpo da requisição, será tratada como uma nova requisição. Uma chamada com a mesma chave de idempotência e o mesmo corpo da requisição retornará a mesma resposta que foi recebida anteriormente, devido a um cache. Se isso ocorrer em um período curto demais pode ocasionar uma resposta HTTP 423, indicando que o recurso está travado e que a requisição original ainda está em processamento. Neste caso, é necessária uma retentativa desta chamada. Uma chamada com a mesma chave de idempotência e com o corpo da requisição diferente do original retornará um erro de idempotência HTTP 409.  Simulações (dry-run) Nossos endpoints que envolvem operações financeiras suportam Simulações (dry-run), permitindo que a usuária visualize com antecedência o que vai acontecer nessa operação.\nEm alguns casos, as Simulações permitem enriquecer os dados de uma operação, como, por exemplo o Pagamento de Boletos.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/integracao\/boas-praticas\/"},{value:"Overview",label:"<p>A Conta Stone é um novo produto da Stone, criado para devolver à cliente o controle de sua conta de pagamentos.\nPara cumprir esse propósito, desenvolvemos a nossa API. Através dela é possível, por exemplo, a usuária dividir a tarefa de gerenciar sua conta com uma Aplicação Parceira ou então se conectar em plataformas de serviços diversos. Além disso, também pode ser utilizada pela Aplicação Parceira para gerenciar sua própria conta. Os diferentes Modelos de Parceria são abordados com maior profundidade no tópico a seguir.\nAtravés do consentimento, a dona da conta tem a segurança de saber ao que a aplicação terá acesso, caso opte por dividir a tarefa de gerenciar sua conta com uma Aplicação Parceira da Stone.\nAlém disso, também é possível para a usuária acessar todas suas contas no mesmo lugar. Ela pode usar suas credenciais para acessar tanto uma conta de pagamento vinculada a ela como pessoa física, como também contas de pagamento vinculadas às pessoas jurídicas de suas empresas. É importante observar que essas credenciais não dão acesso ao serviço de adquirência da Stone. Para esses serviços é preciso acessar o Portal Stone.\nO acesso às contas de pagamento pode ser feito através do Home Bank ou através de nosso aplicativo, disponível para Android e IOS. Para a realização de testes por Aplicações Parceiras que desejam integrar com a nossa API, disponibilizamos o Home Bank em Sandbox.\nAtravés de uma conta de pagamento você tem acesso a serviços financeiros sem precisar ir a um banco. É possível fazer e receber TEDs, como também realizar o pagamento de boletos e outros serviços básicos de uma conta corrente. Entretanto, diferente da conta corrente clássica, tudo pode ser resolvido online e não há a possibilidade de se tornar negativa. Isso torna a gestão da conta mais simples e, inclusive para abrir uma conta, não há necessidade de se deslocar até uma agência. Mesmo assim, se precisar de alguém para te ajudar, a Stone está disponível para contato.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/a-conta-stone\/overview\/"},{value:"Stone Openbank API",label:"<p></p>",url:"https:\/\/stone-co.github.io\/guias\/stone-openbank-api\/"},{value:"Overview",label:"<p>Sejam bem-vindos à seção de Guias da Stone OpenBank API.\nAgora é possível ter funcionalidades de internet banking e de apps de banco no seu negócio!\nO que é a Stone OpenBank API Aqui na Stone a gente acredita não apenas que o cliente tem razão, mas que ele é a nossa razão. Somos fiéis defensores da competição e acreditamos que isso melhora o mercado como um todo, o que, por sua vez, melhora a vida da nossa razão.\nFoi com base nesse sentimento pró-competição que montamos a Stone OpenBank API: a primeira API de Open Banking plugada diretamente no STR.\nA Conta Stone é a nossa oferta para clientes PJ e PF, tanto para aqueles que já pertencem a base da Stone Adquirente, como para aqueles que utilizam outras adquirentes e buscam uma nova forma de se relacionar com sua conta.\nO Aplicativo da Conta Stone é mais um parceiro da Stone OpenBank API, usando exatamente os mesmos acessos e APIs descritos nesse documento. \x26ldquo;Eat your own dogfood\x26rdquo; aplicado na prática.\nAssim como nós pudemos criar o nosso aplicativo de conta em cima dessa API, você pode fazer o mesmo ou integrar as funcionalidades de automação bancária no seu negócio.\nO que oferecemos? Com a API da Conta Stone você pode disponibilizar para os seus clientes:\n Consulta de saldos e extratos Envio e recebimento de transferências tanto de outras Contas Stone como de outros bancos via TED Pagamento de boletos Pagamento de concessionárias e tributos Armazenar contatos favorecidos para envio de transferências para outros bancos  Como funciona a integração? Por enquanto, ainda não estamos realizando on-board de parceiros em auto-serviço. Por isso, todos os interessados em firmar parcerias devem entrar em contato com o nosso time de parcerias seguindo os seguintes passos:\n Preencha nosso formulário para receber as informações necessárias para utilizar nossa API em Sandbox.  A partir do preenchimento do formulário vamos registrar a sua Aplicação no nosso sistema e enviar as credenciais de acesso para o ambiente de Sandbox. Além disso, vamos também criar algumas contas de pagamento em Sandbox para você e sua equipe poderem testar a integração.\nTeste nossas APIS em Sandbox à vontade e, quando estiver pronto, entre em contato com o time de parcerias da Stone através de parcerias@openbank.stone.  O processo envolve algumas reuniões presenciais ou por vídeo para a gente entender o melhor modelo de parceria para o seu negócio.\nApós tudo integrado, vem a homologação.  A Stone, com a ajuda do parceiro, vai realizar testes na Aplicação ainda em Sandbox para garantir que tudo funciona conforme o esperado e que nenhum cliente vai ser prejudicado por bugs em Produção.\nMais informações sobre o processo de integração aqui.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/stone-openbank-api\/overview\/"},{value:"Stone OpenBank",label:"<p></p>",url:"https:\/\/stone-co.github.io\/referencia-da-api\/stone-openbank\/"},{value:"Overview",label:"<p>Sejam bem-vindos à seção de Referências da Stone OpenBank API.\nAtravés da nossa API é possível ter funcionalidades de internet banking e de apps de banco no seu negócio!\nO que é a Stone OpenBank API Aqui na Stone a gente acredita não apenas que o cliente tem razão, mas que ele é a nossa razão. Somos fiéis defensores da competição e acreditamos que isso melhora o mercado como um todo, o que, por sua vez, melhora a vida da nossa razão.\nFoi com base nesse sentimento pró-competição que montamos a Stone OpenBank API: a primeira API de Open Banking plugada diretamente no STR.\nA Conta Stone é a nossa oferta para clientes PJ e PF, tanto para aqueles que já pertencem a base da Stone Adquirente, como para aqueles que utilizam outras adquirentes e buscam uma nova forma de se relacionar com sua conta.\nO Aplicativo da Conta Stone é mais um parceiro da Stone OpenBank API, usando exatamente os mesmos acessos e APIs descritos nesse documento. \x26quot;Eat your own dogfood\x26quot; aplicado na prática.\nAssim como nós pudemos criar o nosso aplicativo de conta em cima dessa API, você pode fazer o mesmo ou integrar as funcionalidades de automação bancária no seu negócio.\nO que oferecemos? Com a API da Conta Stone você pode disponibilizar para os seus clientes:\n Consulta de saldos e extratos Envio e recebimento de transferências tanto de outras Contas Stone como de outros bancos via TED Pagamento de boletos Pagamento de concessionárias e tributos Armazenar contatos favorecidos para envio de transferências para outros bancos  Como funciona a integração? Por enquanto, ainda não estamos realizando on-board de parceiros em auto-serviço. Por isso, todos os interessados em firmar parcerias devem entrar em contato com o nosso time de parcerias seguindo os seguintes passos:\n Preencha nosso formulário para receber as informações necessárias para utilizar nossa API em Sandbox.  A partir do preenchimento do formulário vamos registrar a sua Aplicação no nosso sistema e enviar as credenciais de acesso para o ambiente de Sandbox. Além disso, vamos também criar algumas contas de pagamento em Sandbox para você e sua equipe poderem testar a integração.\nTeste nossas APIS em Sandbox à vontade e, quando estiver pronto, entre em contato com o time de parcerias da Stone através de parcerias@openbank.stone.  O processo envolve algumas reuniões presenciais ou por vídeo para a gente entender o melhor modelo de parceria para o seu negócio.\nApós tudo integrado, vem a homologação.  A Stone, com a ajuda do parceiro, vai realizar testes na Aplicação ainda em Sandbox para garantir que tudo funciona conforme o esperado e que nenhum cliente vai ser prejudicado por bugs em Produção.\nTodo o processo para realização do cadastro se encontra descrito detalhadamente aqui.\nComo integrar com a API Todos os processos e requerimentos para a utilização de nossa API se encontram descritros detalhadamente em nossa Documentação:\nQuickstart Faça a sua primeira movimentação financeira de teste seguindo esses três passos!\nAmbientes da API Como funcionam nossos ambientes de Sandbox e Produção.\nA Conta Stone Como funciona esse novo produto da Stone, criado para devolver à cliente o controle de sua conta de pagamentos.\nModelos de Parceria Como funcionam os principais modelos de parceria que oferecemos para aplicações que desejam integrar com a nossa API.\nAplicativos O que são os aplicativos desenvolvidos pela Stone e por parceiros.\nCadastro da Aplicação Passo a passo para obter acesso e conseguir se autenticar em nossa API de Sandbox.\nAutenticação Aqui você encontra todos os detalhes sobre o processo de se autenticar na nossa API.\nTestando a API Teste nossa API no ambiente de Sandbox  para garantir que tudo funciona conforme o esperado e que nenhuma cliente vai ser prejudicada por bugs em Produção.\nConsentimento Descrição de todo o processo de como obter acesso às contas de pagamento de suas clientes.\nAprovação Como a dona da conta permite que uma transação criada pelo parceiro seja realizada.\nWebhooks Como notificamos o sistema parceiro da ocorrência de eventos.\nBoas Práticas Como armazenar dados e realizar operações em nossa API de forma segura.\n</p>",url:"https:\/\/stone-co.github.io\/referencia-da-api\/stone-openbank\/overview\/"},{value:"Referência da API",label:"<p></p>",url:"https:\/\/stone-co.github.io\/referencia-da-api\/"},{value:"Cadastro da Aplicação",label:"<p>Primeiros Passos O primeiro passo para a integração é obter o acesso ao nosso ambiente de Sandbox. Este ambiente reflete o de Produção e deve ser utilizado para testes.\nUtilizamos OpenID Connect para a autenticação em nossa API. Para obter acesso e conseguir se autenticar em nossa API de Sandbox, siga os seguintes passos:\n Solicite o ClientID preenchendo o formulário.    Será necessário gerar um par de chaves RSA 4096 e compartilhar a chave pública conosco no formato .pem. O passo a passo para gerar essas chaves está detalhado abaixo, como também no formulário.\n  A URI de redirecionamento faz parte do fluxo OAuth 2.0.\n  Enviaremos o seu ClientID para o e-mail cadastrado. Com ele você conseguirá realizar o processo de autenticação. Após a realização de testes através de nosso Sandbox e estiver pronto para a Homologação, entre em contato através de parcerias@openbank.stone.  Para entender qual modelo de parceria melhor se aplica a sua aplicação, pode ser necessário realizar algumas reuniões presenciais ou por vídeo com a gente.\nRealizaremos o procedimento de homologação para garantir o funcionamento da integração. Em seguida, a utilização em Produção já será possível.  Atenção à chave enviada no formulário A chave que deverá ser enviada para a Stone através do formulário é a chave pública e não a chave chave privada.\n Operações em nossa API Em SandBox, por padrão, a aplicação nasce com as seguintes autorizações:\n Realizar transferências externas; Realizar transferências internas; Pagar boletos; Ler o extrato; Ler o saldo; Ler os contatos de contas de pagamento; Criar, editar e deletar um contato de conta de pagamento; Ler taxas.  Quando colocarmos a Aplicação em produção, a Stone e o Parceiro irão validar quais acessos são realmente necessários para a solução criada, ajustando as autorizações.\nGerando o par de chaves Para gerar as chaves recomendamos o uso da ferramenta OpenSSL, disponível para Linux, MacOS e Windows.\nPara Linux, é uma ferramenta padrão que já vem instalada em quase todas as distribuições.\nPara MacOS, há algumas formas de instalar, sendo o uso da ferramenta \x26ldquo;brew\x26rdquo; um dos mais simples.\nPara Windows, infelizmente é preciso configurar um pouco mais. É possível adquirí-la através da Página de Download, e obter detalhes sobre o processo de instalação através do Tutorial de Instalação, em inglês.\nApós a instalação, você deve acrescentar o caminho do programa na variável PATH e adicionar mais uma variável OPENSSL_CONF para o arquivo openssl.cfg, que normalmente vai ser C:\\Program Files\\OpenSSL-Win64\\bin\\openssl.cfg.\nMas atenção para ajustar o caminho para o local onde você instalou a ferramenta:\n  Está pronto para gerar as chaves!\nEm todas as plataformas - Linux, MacOS e Windows - os comandos do OpenSSL são iguais:\nopenssl genrsa -out mykey.pem 4096 openssl rsa -in mykey.pem -pubout \x26gt; mykey.pub </p>",url:"https:\/\/stone-co.github.io\/guias\/integracao\/cadastro-da-aplicacao\/"},{value:"A Conta Stone",label:"<p></p>",url:"https:\/\/stone-co.github.io\/guias\/a-conta-stone\/"},{value:"Modelos De Parceria",label:"<p>Como funcionam os principais modelos de parceria que oferecemos para aqueles que desejam integrar com a nossa API.  A Stone oferece dois modelos principais de parceria:\nOpen Banking Permite que o parceiro integre na API para disponibilizar todas as funcionalidades da Conta Stone para a usuária por meio de sua Aplicação. Dessa forma, é possível oferecer à usuária um serviço mais completo, agregando valor ao seu produto.\nA usuária interage com seu serviço através de uma interface de sua responsabilidade.\nA usuária enxerga a Stone como provedor financeiro, agregando a imagem de confiança financeira da Stone ao seu serviço.\nA aprovação de cash-out (qualquer saída de recurso da conta) sempre terá que ser aprovada pela usuária por meio de autenticação no ambiente Stone, através do aplicativo Aprovador. Dessa forma, o parceiro fica protegido da responsabilidade na movimentação de recursos financeiros.\nConta de Liquidação Facilita a gestão de operações financeiras complexas, através de um token para operar a sua própria conta com acesso ao Sistema de Pagamentos Brasileiro (SPB). Facilitadores (subadquirentes) e emissores de moeda eletrônica (wallets) podem se beneficiar de uma API RESTful conectada no backbone do Banco Central e integrada no last mile de todos os produtos básicos de conta que você precisa para cash-in e cash-out no seu serviço financeiro. A API de Openbank da Stone foi criada para aguentar um grande número de transações de forma rápida, simples e segura.\nNesse modelo você é a cliente final dona da conta. Não criamos, gerimos ou nos responsabilizamos pelas credenciais de seus clientes em seu ambiente. Todo fluxo financeiro é feito através de sua própria Conta Stone. Todo monitoramento e report de atividade para os reguladores serão feitos levando em consideração o parceiro como cliente final. Por isso, é importante que o parceiro mantenha monitoramento e controles dos seus clientes em seu lado.\nTodos os serviços disponíveis na Conta Stone poderão ser oferecidos para seus clientes, com a diferença que o fluxo financeiro é centralizado na sua conta.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/a-conta-stone\/modelos-de-parceria\/"},{value:"Quickstart",label:"<p>Faça a sua primeira movimentação financeira de teste seguindo esses três passos:\n Cadastre-se no Stone OpenBank API; Escolha a sua linguagem\/ferramenta preferida; Crie uma transação.  1 - Cadastre-se no Stone OpenBank ClientID\nObtenha o seu Access Token, por meio deste formulário. Somente com o Access Token em mãos você consegue realizar as autenticações necessárias para realizar as chamadas na Stone Open Bank API.\nApós o preenchimento do formulário, o time de parcerias do Stone Open Bank irá gerar um ClientID. Uma vez cadastrado e com a seu ClientID em mãos, você poderá realizar o processo de autenticação da aplicação, que permitirá que obtenha-se o Acess Token. Este processo de autenticação  consiste nas seguintes etapas:\nGeração de um token que contenha\n client_id: identificador enviado pelo time de suporte OpenBank; sub: igual ao client_id; realm: \x26ldquo;stone_bank\x26rdquo;; aud: https:\/\/sandbox-accounts.openbank.stone.com.br\/auth\/realms\/stone_bank; exp: horário da expiração do token em segundos; nbf: horário da geração do token em segundos.  Obtenção de access e refresh tokens\nUma vez obtido o token, deve-se configurar os seguintes parâmetros e realizar a seguinte chamada:\n**POST** https:\/\/sandbox-accounts.openbank.stone.com.br\/auth\/realms\/stone_bank\/protocol\/openid-connect\/token content-type x-www-form-urlencoded  client_id: identificador enviado pelo time de suporte OpenBank; grant_type: sempre será client_credentials; client_assertion: token obtido na etapa de geração do token; client_assertion_type: sempre será \x26ldquo;urn:ietf:params:oauth:client-assertion-type:jwt-bearer\x26rdquo;.  Obtido sucesso, o servidor retornará o access_token e o refresh_token da conta da Aplicação. O fluxo acima é um exemplo de como iniciar a sua integração com a Stone Open Bank API. Para detalhes sobre o processo de integração, consultar a página Como Integrar com a API.\n 2 - Escolha a sua linguagem A Stone Open Bank disponibiliza sua infraestrutura por meio de uma API RESTful e respostas em JSON.\nTodas as requisições são feitas no endpoint base: https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1\n 3 - Crie uma TED Depois de se cadastrar, pegar o seu token de teste e escolher a sua linguagem já é possível começar a movimentar a sua conta de teste! Para realizar uma movimentação de TED teste, por exemplo, você pode fazer uma chamada na Stone Open Bank API. Pode-se observar um exemplo de chamada teste abaixo:\ncURL curl --request POST \\ --url https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1\/external_transfers \\ --header \x27Content-Type: application\/json\x27 \\ --header \x27authorization: Bearer {token}\x27 \\ --data \x27{\x26quot;amount\x26quot;:3000,\x26quot;target\x26quot;:{\x26quot;account\x26quot;:{\x26quot;account_code\x26quot;:\x26quot;654321\x26quot;,\x26quot;branch_code\x26quot;:\x26quot;1234\x26quot;,\x26quot;institution_code\x26quot;:\x26quot;260\x26quot;},\x26quot;entity\x26quot;:{\x26quot;cpf\x26quot;:\x26quot;05971627007\x26quot;,\x26quot;name\x26quot;:\x26quot;Nome do destinatário\x26quot;}},\x26quot;account_id\x26quot;:\x26quot;f49a9d13-18dc-4811-b286-edd168a428b2\x26quot;}\x27 Ruby require \x26#39;uri\x26#39; require \x26#39;net\/http\x26#39; url = URI(\x26#34;https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1\/external_transfers\x26#34;) http = Net::HTTP.new(url.host, url.port) http.use_ssl = true request = Net::HTTP::Post.new(url) request[\x26#34;authorization\x26#34;] = \x26#39;Bearer {token}\x26#39; request.body = \x26#34;{\\\x26#34;amount\\\x26#34;:10050,\\\x26#34;target\\\x26#34;:{\\\x26#34;account\\\x26#34;:{\\\x26#34;account_code\\\x26#34;:\\\x26#34;1456879\\\x26#34;,\\\x26#34;branch_code\\\x26#34;:\\\x26#34;0633\\\x26#34;,\\\x26#34;institution_code\\\x26#34;:\\\x26#34;379\\\x26#34;},\\\x26#34;entity\\\x26#34;:{\\\x26#34;cpf\\\x26#34;:\\\x26#34;67385417752\\\x26#34;,\\\x26#34;name\\\x26#34;:\\\x26#34;Vitoria Silva Correia\\\x26#34;}},\\\x26#34;account_id\\\x26#34;:\\\x26#34;200568\\\x26#34;}\x26#34; response = http.request(request) puts response.read_body Javascript var data = JSON.stringify({ \x26#34;amount\x26#34;: 10050, \x26#34;target\x26#34;: { \x26#34;account\x26#34;: { \x26#34;account_code\x26#34;: \x26#34;1456879\x26#34;, \x26#34;branch_code\x26#34;: \x26#34;0633\x26#34;, \x26#34;institution_code\x26#34;: \x26#34;379\x26#34; }, \x26#34;entity\x26#34;: { \x26#34;cpf\x26#34;: \x26#34;67385417752\x26#34;, \x26#34;name\x26#34;: \x26#34;Vitoria Silva Correia\x26#34; } }, \x26#34;account_id\x26#34;: \x26#34;200568\x26#34; }); var xhr = new XMLHttpRequest(); xhr.withCredentials = true; xhr.addEventListener(\x26#34;readystatechange\x26#34;, function () { if (this.readyState === this.DONE) { console.log(this.responseText); } }); xhr.open(\x26#34;POST\x26#34;, \x26#34;https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1\/external_transfers\x26#34;); xhr.setRequestHeader(\x26#34;authorization\x26#34;, \x26#34;Bearer {token}\x26#34;); xhr.send(data); Python import requests url = \x26#34;https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1\/external_transfers\x26#34; payload = \x26#34;{\\\x26#34;amount\\\x26#34;:10050,\\\x26#34;target\\\x26#34;:{\\\x26#34;account\\\x26#34;:{\\\x26#34;account_code\\\x26#34;:\\\x26#34;1456879\\\x26#34;,\\\x26#34;branch_code\\\x26#34;:\\\x26#34;0633\\\x26#34;,\\\x26#34;institution_code\\\x26#34;:\\\x26#34;379\\\x26#34;},\\\x26#34;entity\\\x26#34;:{\\\x26#34;cpf\\\x26#34;:\\\x26#34;67385417752\\\x26#34;,\\\x26#34;name\\\x26#34;:\\\x26#34;Vitoria Silva Correia\\\x26#34;}},\\\x26#34;account_id\\\x26#34;:\\\x26#34;200568\\\x26#34;}\x26#34; headers = {\x26#39;authorization\x26#39;: \x26#39;Bearer {token}\x26#39;} response = requests.request(\x26#34;POST\x26#34;, url, data=payload, headers=headers) print(response.text) C# var client = new RestClient(\x26#34;https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1\/external_transfers\x26#34;); var request = new RestRequest(Method.POST); request.AddHeader(\x26#34;authorization\x26#34;, \x26#34;Bearer {token}\x26#34;); request.AddParameter(\x26#34;undefined\x26#34;, \x26#34;{\\\x26#34;amount\\\x26#34;:10050,\\\x26#34;target\\\x26#34;:{\\\x26#34;account\\\x26#34;:{\\\x26#34;account_code\\\x26#34;:\\\x26#34;1456879\\\x26#34;,\\\x26#34;branch_code\\\x26#34;:\\\x26#34;0633\\\x26#34;,\\\x26#34;institution_code\\\x26#34;:\\\x26#34;379\\\x26#34;},\\\x26#34;entity\\\x26#34;:{\\\x26#34;cpf\\\x26#34;:\\\x26#34;67385417752\\\x26#34;,\\\x26#34;name\\\x26#34;:\\\x26#34;Vitoria Silva Correia\\\x26#34;}},\\\x26#34;account_id\\\x26#34;:\\\x26#34;200568\\\x26#34;}\x26#34;, ParameterType.RequestBody); IRestResponse response = client.Execute(request); Caso queira saber mais sobre as chamadas disponíveis na nossa API, consulte nossos endpoints em API Reference.\n4 - Construindo o seu App Com a resposta gerada pela requisição da TED acima, você poderá elaborar uma tela exibindo as informações da transferência realizada. Por exemplo, para construir a tela abaixo:\n  É utilizada a requisição citada 3º passo, tendo como resposta o seguinte JSON:\n{ \x26quot;amount\x26quot;: 10050, \x26quot;approved_at\x26quot;: \x26quot;2018-10-08T22:13:51Z\x26quot;, \x26quot;approved_by\x26quot;: \x26quot;user:380f9968-8946-4f88-a781-be8b7efc1f90\x26quot;, \x26quot;created_at\x26quot;: \x26quot;2018-10-08T22:13:51Z\x26quot;, \x26quot;created_by\x26quot;: \x26quot;user:380f9968-8946-4f88-a781-be8b7efc1f90\x26quot;, \x26quot;failed_at\x26quot;: null, \x26quot;fee\x26quot;: 0, \x26quot;id\x26quot;: \x26quot;79573d4a-613a-4ac7-8970-39c39fc18e5a\x26quot;, \x26quot;refunded_at\x26quot;: null, \x26quot;rejected_at\x26quot;: null, \x26quot;rejected_by\x26quot;: null, \x26quot;settled_at\x26quot;: null, \x26quot;target\x26quot;: { \x26quot;account\x26quot;: { \x26quot;account_code\x26quot;: \x26quot;1456879\x26quot;, \x26quot;branch_code\x26quot;: \x26quot;0633\x26quot;, \x26quot;institution_code\x26quot;: \x26quot;379\x26quot; }, \x26quot;entity\x26quot;: { \x26quot;cpf\x26quot;: \x26quot;67385417752\x26quot;, \x26quot;name\x26quot;: \x26quot;Vitoria Silva Correia\x26quot; } } }  Entenda mais sobre a Transfers API e a sua requisição de TED Detalhes sobre a Transfers API se encontram na página Transferir para Outros Bancos.\n </p>",url:"https:\/\/stone-co.github.io\/guias\/stone-openbank-api\/quickstart\/"},{value:"Autenticação",label:"<p>A nossa API é RESTful, e todas suas respostas são em JSON, nos endpoint base, por ambiente:\n Sandbox: https:\/\/sandbox-api.openbank.stone.com.br Produção: https:\/\/api.openbank.stone.com.br  Seguimos alguns padrões para alguns tipos de dados em toda a nossa API. A seguir, juntamos alguns desses padrões para simplificar a vida da desenvolvedora.\nRealizando Chamadas Autenticadas A nossa API só aceita chamadas autenticadas, ou seja, chamadas cujo sujeito da ação conseguimos identificar.\nCaso ainda não tenha realizado o procedimento para obter seu token de acesso, por favor siga o passo a passo descrito na página Autenticação de nossos Guias.\nCaso tenha em mãos seu token de acesso, já é possível realizar chamadas autenticadas.\nPara isso, exigimos que nas requisições HTTP exista no cabeçalho um campo chamado authorization, cujo valor será \x26quot;Bearer\x26quot; seguido do token de acesso.\nExemplo de cabeçalho de uma chamada autenticada:\nGET \/api\/v1\/accounts HTTP\/1.1 Host: sandbox-api.openbank.stone.com.br User-Agent: Nome da aplicação Accept: *\/* authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV*adQssw5c  Autenticação nos Exemplos Cada exemplo de endpoint desta documentação tem um campo especial para o ACCESS_TOKEN, acessível clicando no botão Try It.\n </p>",url:"https:\/\/stone-co.github.io\/referencia-da-api\/stone-openbank\/autenticacao\/"},{value:"Guias",label:"<p></p>",url:"https:\/\/stone-co.github.io\/guias\/"},{value:"Parceiros",label:"<p></p>",url:"https:\/\/stone-co.github.io\/parceiros\/"},{value:"Integração",label:"<p></p>",url:"https:\/\/stone-co.github.io\/guias\/integracao\/"},{value:"Autenticação",label:"<p>Detalhes sobre o processo de se autenticar na nossa API.  Segurança sempre foi um assunto complexo, principalmente por ter uma terminologia específica. Para facilitar ao máximo a integração com a nossa API, procuramos adotar padrões estabelecidos de mercado.\nAutenticação de Aplicativos Parceiros Cada Aplicativo recebe um identificador exclusivo chamado ClientID quando é criado. Esse ID não pode ser modificado e será usado no token de acesso do seu Aplicativo quando chamar a API. Outra informação importante é o *par de chaves *do seu Aplicativo, que deve ser mantida confidencial em todos os momentos. Se alguém obtiver acesso a sua chave privada, essa pessoa poderá acessar recursos protegidos em nome do seu Aplicativo. Isso não pode acontecer sob hipótese alguma. A desenvolvedora deve usar essa chave privada para assinar os tokens enviados para a Stone e nos enviar a chave pública para verificarmos a assinatura.\nAutenticação com OAuth e Open ID Connect OAuth 2.0 é um padrão de autorização que permite à usuária conceder acesso limitado a seus recursos na Conta Stone para Aplicativos de Parceiros, sem precisar expor suas credenciais. Ou seja, a cliente não precisa compartilhar seu login e senha com ninguém. Já o OpenID Connect é uma camada de identidade construída em cima do OAuth 2.0 e que permite a fácil verificação da identidade da usuária, bem como a capacidade de obter informações básicas de perfil do provedor de identidade (no caso, a Conta Stone).\nAutenticando a Aplicação Parceira A nossa API só aceita chamadas autenticadas, ou seja, chamadas cujo sujeito da ação conseguimos identificar.\nPara isso exigimos que nas requisições HTTP exista no cabeçalho um campo chamado authorization, cujo valor será \x26ldquo;Bearer\x26rdquo; seguido do token de acesso. Os próximos tópicos explicam como obter esse token de acesso.\nExemplo de cabeçalho de uma chamada autenticada:\nGET \/api\/v1\/accounts HTTP\/1.1 Host: sandbox-api.openbank.stone.com.br User-Agent: curl\/7.61.1 Accept: *\/* authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c Dessa forma, após o cadastro da Aplicação da desenvolvedora, é necessário implementar a autenticação.\nComo foi detalhado acima, nosso fluxo se baseia na especificação OAuth 2.0 e OpenID Connect. O fluxo de integração OAuth 2.0 que usamos é o de client credentials. Neste fluxo, a desenvolvedora irá precisar:\n1. Gerar um token JWT com as configurações da sua Aplicação, assinando com sua chave privada.\n2. Fazer uma requisição POST para nosso servidor de autenticação, enviando o JWT. Se for um token válido, enviaremos como resposta um token de acesso.\n3. Usar esse access_token para fazer as chamadas autenticadas.\n1. Gerando o token JWT JWT é uma especificação para gerarmos tokens que sejam assinados e\/ou criptografados. Nesta página temos várias bibliotecas de desenvolvimento em várias linguagens que implementam esta especificação.\nBasicamente, um JWT possui 3 partes:\n header: possui informações sobre o algoritmo de criptografia utilizado, entre outros metadados deste processo, como um id da chave utilizada. Na nossa API utilizaremos sempre o algoritmo \x26ldquo;RS256\x26rdquo;. Falaremos mais sobre ele. Um exemplo de *header *seria:  { \x26quot;alg\x26quot;: \x26quot;RS256\x26quot;, \x26quot;typ\x26quot;: \x26quot;JWT\x26quot; } Este deve ser encodado em base 64 para ser incluído no token. Para o exemplo, fica: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\n payload: um conjunto de alegações (claims, do inglês) que possuem a estrutura chave\/valor. É aqui que colocamos informações como tempo de expiração do token, qual o id da Aplicação e etc. signature: a assinatura do header e payload usando o algoritmo descrito no header e a chave privada.  Claims Para conseguir se autenticar com sucesso, a desenvolvedora precisará colocar nos claims os seguintes valores:\n   Nome Valor     exp Tempo de expiração do token em segundos desde o início da era UNIX (1970). É UTC e não pode ser maior que 2hs. Ex: \\\x26quot;exp\\\x26quot;: 1542235633   nbf \x26ldquo;Not before\x26rdquo;, ou seja, data a partir da qual o token é válido. É UTC. Ex: \\\x26quot;nbf\\\x26quot;: 1542235633   aud Quem é a \x26ldquo;audiência\x26rdquo; deste token. No caso, é o nosso servidor de autenticação. Para o ambiente de Sandbox será: https:\/\/sandbox-accounts.openbank.stone.com.br\/auth\/realms\/stone_bank Para Produção será: https:\/\/accounts.openbank.stone.com.br\/auth\/realms\/stone_bank   realm Qual é o \x26ldquo;reino\x26rdquo; das nossas usuárias. Será sempre \x26ldquo;stone_bank\x26rdquo;.   sub O sujeito referente ao token. Deve ser o ClientID enviado à desenvolvedora pós-cadastro da Aplicação.   clientId Mesmo valor de sub, ou seja, o ClientID enviado à desenvolvedora pós-cadastro da Aplicação.   jti Identificador único do token gerado. Normalmente se utiliza um UUID, mas não é obrigatório usar esse formato desde que a unicidade seja garantida. Mais informações.   iat Momento em que o token foi gerado. É UTC. Ex. \x26quot;iat\x26quot;: 1542235633\x26rdquo;    Usando a chave privada e o algoritmo \x26ldquo;RS256\x26rdquo;, a desenvolvedora consegue gerar e assinar o Token JWT com qualquer uma das libs listadas neste site.\nNós temos guardada de forma segura a **chave pública **que usaremos para validar este token.\nEsse é um processo de criptografia assimétrica, no qual usaremos o par de chaves pública e privada gerado pela desenvolvedora no momento do cadastro da Aplicação.\nRS256 Este algoritmo especificado nesta RFC usa criptografia \x26ldquo;RSASSA-PKCS1-v1_5 com SHA-256\x26rdquo;. É o mesmo padrão de integração das APIs que muitas outras grandes empresas utilizam.\n2. Fazendo a requisição para receber o token de acesso Após a geração do token local, é preciso fazer uma chamada para o nosso servidor de autenticação para que a gente faça a validação e retorne um access_token nosso.\nEsta chamada será nas seguintes URLs (por ambiente):\n Sandbox: https:\/\/sandbox-accounts.openbank.stone.com.br\/auth\/realms\/stone_bank\/protocol\/openid-connect\/token Produção: https:\/\/accounts.openbank.stone.com.br\/auth\/realms\/stone_bank\/protocol\/openid-connect\/token  A chamada é com o método POST com o header Content-Type e User-Agent. O Content-Type informado deve ser x-www-form-urlencoded (o mesmo usado por submissão de formulários HTML) e o header User-Agent deve estar habilitado.\nEx.:\n\x26quot;user-agent\x26quot;: \x26quot;Nome da aplicação\x26quot;, \x26quot;content-type\x26quot;: \x26quot;application\/x-www-form-urlencoded\x26quot;    Nome Valor     client_id É o valor enviado para a desenvolvedora pós-cadastro da Aplicação.   grant_type Será sempre \x26ldquo;client_credentials\x26rdquo;.   client_assertion Aqui deve ser o token que a desenvolvedora gerou.   client_assertion_type Sempre será urn:ietf:params:oauth:client-assertion-type:jwt-bearer, que é o que fecha o fluxo de client credentials para o servidor.    Um exemplo de chamada de autenticação:\ncurl -X POST https:\/\/sandbox-accounts.openbank.stone.com.br\/auth\/realms\/stone_bank\/protocol\/openid-connect\/token -H \x27content-type: application\/x-www-form-urlencoded\x27 -d \x27client_id=ID_EXEMPLO\x26amp;grant_type=client_credentials\x26amp;client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer\x26amp;client_assertion=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\x27 Exemplo de resposta:\n{ \x26quot;access_token\x26quot;: \x26quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ijh3eWRUZGpzTEdYVSJ9.eyJqdGkiOiIzM2RlNjg2Mi1iYmVkLTQ3ZWYtYTY5Yi0wNDAzNTI0YTRhNGEiLCJleHAiOjE1NTkyNDg3OTUsIm5iZiI6MCwiaWF0IjoxNTU5MjQ3ODk1LCJpc3MiOiJodHRwczovL3NhbmRib3gtYWNjb3VudHMub3BlbmJhbmsuc3RvbmUuY29tLmJyL2F1dGgvcmVhbG1zL3N0b25lX2JhbmsiLCJzdWIiOiJjMWExZmE5NC0zOTc4LTRhNjgtODBlNy1mZWU2ZTkwNmNiMmUiLCJ0eXAiOiJCZWFyZXIiLCJhenAiOiJhZG1pbi1jbGkiLCJhdXRoX3RpbWUiOjAsInNlc3Npb25fc3RhdGUiOiJhN2YxN2QxMC1jMGY1LTQzMzItOWE5MC1lNDQxMTVmMWNlMGEiLCJhY3IiOiIxIiwic2NvcGUiOiJleHBlbmQ6dHJhbnNmZXJzOmludGVybmFsIGVudGl0eTpsZWdhbF93cml0ZSBlbnRpdHk6d3JpdGUgcHJpbmNpcGFsOmNvbnNlbnQgZW1haWwgZXhwZW5kOnRyYW5zZmVyczpleHRlcm5hbCBzdG9uZV9zdWJqZWN0X2lkIGV4cGVuZDpyZWFkIGV4cGVuZDpib2xldG9pc3N1YW5jZSBlbnRpdHk6cmVhZCBwcm9maWxlIHBheW1lbnRhY2NvdW50OiogZXhwZW5kOnBheW1lbnRzIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsInN0b25lX3N1YmplY3RfaWQiOiJ1c2VyOjNmMDcwN2NiLWEyYzgtNDlhMS04NDc4LWFjMDg1MGY5Njc4MCIsIm5hbWUiOiJKb2FvIiwicHJlZmVycmVkX3VzZXJuYW1lIjoiam9hby5leGVtcGxvQGVtYWlsLmNvbS5iciIsImdpdmVuX25hbWUiOiJKb2FvIiwiZW1haWwiOiJqb2FvLmV4ZW1wbG9AZW1haWwuY29tLmJyIn0.baf0-ZMg_IPtoReTpQBnMIYPjrLWFklPT7T1CGE2ecxfxt-a3h1CSdveK0Xd0f9FWna6obcSIonHn7HD0mJnxwBoIK8w6_cg_ODTS-l2jgGWVTl-jN41rdyTg5kgtTT6M3v02QJxTOfklo9mpW4tX8cZorx5vP_ykb5Kk186PGxYTJ9mGwQEuyrHl7-mc8aN7x10Ue7P_fk2Br43T2uR7LoFFIVM9I45p1hntZx-e59alleIuUqnZzk5Vo8knk67ZEJEAWOiigS0yyyy9gT3wqPypBYnoP3SMVws7e6lfKuZasCS58z8arJiYVQVgF6xSoQQdDBTY4I1_5kL-phmAA\x26quot;, \x26quot;expires_in\x26quot;: 900, \x26quot;refresh_expires_in\x26quot;: 1800, \x26quot;refresh_token\x26quot;: \x26quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ijh3eWRUZGpzTEdYVSJ9.eyJqdGkiOiIzM2RlNjg2Mi1iYmVkLTQ3ZWYtYTY5Yi0wNDAzNTI0YTRhNGEiLCJleHAiOjE1NTkyNDg3OTUsIm5iZiI6MCwiZW1haWxfdmVyaWZpZWQiOnRydWUsInN0b25lX3N1YmplY3RfaWQiOiJ1c2VyOjNmMDcwN2NiLWEyYzgtNDlhMS04NDc4LWFjMDg1MGY5Njc4MCIsIm5hbWUiOiJKb2FvIiwicHJlZmVycmVkX3VzZXJuYW1lIjoiam9hby5leGVtcGxvQGVtYWlsLmNvbS5iciIsImdpdmVuX25hbWUiOiJKb2FvIiwiZW1haWwiOiJqb2FvLmV4ZW1wbG9AZW1haWwuY29tLmJyIn0.lRepHkrIfYgkU_t39rwMxVD8GlH2-_Kq1ri75wA7Z1HRwB0gIQuf_ytWA_eJ_Bk16ZRGWl210uTxHoDSqpF0fowtRjeGkcME19Ie2jLYCX_IZZEjPLZtpEoAQRF4PXbYA4getLN_u3jr6i5CjoLXXhUV0OdmE0IWIGGh7uJFcpioYMDk4iagCdVVnZea5qhoV4Gejbfd9QG2_Xx9JxLuxLAPAoE0Hr_EDlJ8YsCZjzz36HEwjjYJM-imFykHBilVATbq28PnQfSm7Y58i3ElVdy27h-xUfx1YOxteChFc3Xb_PBBK8LPxZDcbQD6RGq7Qs2aO0NtxuENpne9q-aOjA\x26quot;, \x26quot;token_type\x26quot;: \x26quot;bearer\x26quot;, \x26quot;not-before-policy\x26quot;: 0, \x26quot;session_state\x26quot;: \x26quot;a7f07d10-c0f5-4332-95f2-e44115f1ce0a\x26quot;, \x26quot;scope\x26quot;: \x26quot;expend:transfers:internal entity:legal_write entity:write principal:consent email expend:transfers:external stone_subject_id expend:read expend:boletoissuance entity:read profile paymentaccount:* expend:payments\x26quot; } 3. Usando o access_token da resposta Se tudo deu certo no passo anterior, a resposta do servidor será um JSON com uma chave access_token, onde terá o valor de um token de sessão.\nComo falamos no início dos tópicos anteriores, para usar este token basta colocá-lo no header Authorization com o valor Bearer ACCESS_TOKEN. Aqui, a desenvolvedora deve substituir \x26ldquo;ACCESS_TOKEN\x26rdquo; pelo valor recebido. Autenticação nos exemplos Cada exemplo de endpoint desta documentação tem um campo especial para o ACCESS_TOKEN.\n Pronto! Com isto já é possível fazer uma chamada autenticada para a nossa API. A URL é (por ambiente):\n Sandbox: https:\/\/sandbox-api.openbank.stone.com.br Produção: https:\/\/api.openbank.stone.com.br  Bem-vinda ao time de fintechs do futuro!\nEsta chamada retorna um access_token que pode ser usado nas próximas chamadas.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/integracao\/autenticacao\/"},{value:"Aplicativos",label:"<p>Aplicativos são desenvolvidos pela própria Stone ou por parceiros, e oferecem soluções de gestão da conta de pagamento, mais ou menos específicas. A Stone possui um web app e aplicativos mobile, para iOS e Android, que permitem a gestão da Conta Stone. Esses aplicativos usam as mesmas APIs e métodos de autenticação que os Aplicativos de Parceiros.\nAplicativos de Parceiros são controlados por pessoas ou organizações que não são diretamente ligadas à Stone. Esses aplicativos não conseguem administrar as contas às quais possuem acesso (não podem redefinir a senha, mudar dados cadastrais, etc), mas podem operacionalizar essas contas (iniciar envios de TEDs, iniciar pagamentos, etc) quando possuem consentimento.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/a-conta-stone\/aplicativos\/"},{value:"Ambientes da API",label:"<p>A API pode ser utilizada através de dois ambientes completamente separados: usuárias criadas em ambiente de Sandbox não existem em Produção, e vice-versa.\nAmbiente de Sandbox É destinado a testes e pode ser acessado pelo endpoint https:\/\/sandbox-api.openbank.stone.com.br.\nAmbiente de Produção É onde ocorrem transações em contas reais e pode ser acessado pelo endpoint https:\/\/api.openbank.stone.com.br.\nNós não liberamos o acesso para Produção antes de realizar testes em Sandbox para garantir a confiabilidade da integração.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/stone-openbank-api\/ambientes-da-api\/"},{value:"Data e Hora",label:"<p>Representação de datas e horários.\n Todas as datas com horário seguem o padrão ISO8601 Extended Format, em UTC com anotação do offset. Ex: 2018-11-06T22:10:00Z Todas as datas sem horário estão no mesmo padrão. Ex: 2018-11-06  Para evitar problemas, sempre mandamos as datas em UTC e anotamos essa informação na string codificada.\nUTC UTC (Coordinated Universal Time), como o próprio nome diz, é coordenado internacionalmente. O horário de Brasília é atrasado 3 horas em relação a esse horário. Tenha isso em mente sempre que for gerar um token ou fazer algum agendamento!\x26quot;,\n </p>",url:"https:\/\/stone-co.github.io\/referencia-da-api\/stone-openbank\/data-e-hora\/"},{value:"SDKs",label:"<p></p>",url:"https:\/\/stone-co.github.io\/sdks\/"},{value:"Tutoriais",label:"<p></p>",url:"https:\/\/stone-co.github.io\/guias\/tutoriais\/"},{value:"Testando a API",label:"<p>Nossa API é baseada em REST e a comunicação é feita utilizando métodos de requisição HTTP (GET, POST, PUT, DELETE, etc).\nPara todos os endpoints, o formato esperado para o content_type é sempre application\/json. A URL base para a API em Sandbox é https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1.\nAbaixo temos um exemplo de uma requisição válida para a API em Sandbox, utilizando a ferramenta curl:\ncurl --request GET \\ --url https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1\/institutions\/197 O retorno das chamadas na API será, por padrão, um objeto do tipo JSON. A chamada anterior tem a seguinte resposta:\n{ \x26quot;ispb_code\x26quot;:\x26quot;16501555\x26quot;, \x26quot;name\x26quot;:\x26quot;Stone Pagamentos S.A.\x26quot;, \x26quot;number_code\x26quot;:\x26quot;197\x26quot;, \x26quot;short_name\x26quot;:\x26quot;STONE PAGAMENTOS S.A.\x26quot; } A chamada abaixo é usada para enviar uma TED. Nesse caso, adicionamos como headers o tipo de conteúdo como sendo application\/json e a autenticação via Bearer token, como discutida na sessão de autenticação.\ncurl --request POST \\ --url https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1\/external_transfers \\ --header \x27Content-Type: application\/json\x27 \\ --header \x27authorization: Bearer {token}\x27 \\ --data \x27{\x26quot;amount\x26quot;:3000,\x26quot;target\x26quot;:{\x26quot;account\x26quot;:{\x26quot;account_code\x26quot;:\x26quot;654321\x26quot;,\x26quot;branch_code\x26quot;:\x26quot;1234\x26quot;,\x26quot;institution_code\x26quot;:\x26quot;260\x26quot;},\x26quot;entity\x26quot;:{\x26quot;cpf\x26quot;:\x26quot;05971627007\x26quot;,\x26quot;name\x26quot;:\x26quot;Nome do destinatário\x26quot;}},\x26quot;account_id\x26quot;:\x26quot;f49a9d13-18dc-4811-b286-edd168a428b2\x26quot;}\x27 Essas requisições geram respostas, conforme podemos ver abaixo:\n{ \x26quot;amount\x26quot;:16600, \x26quot;approval_expired_at\x26quot;:null, \x26quot;approved_at\x26quot;:\x26quot;2019-06-07T18:57:57Z\x26quot;, \x26quot;approved_by\x26quot;:\x26quot;user:b2b80e9a-7412-47de-b303-2f70f3c8e279\x26quot;, \x26quot;cancelled_at\x26quot;:null, \x26quot;created_at\x26quot;:\x26quot;2019-06-07T18:57:57Z\x26quot;, \x26quot;created_by\x26quot;:\x26quot;user:b2b80e9a-7412-47de-b303-2f70f3c8e279\x26quot;, \x26quot;delayed_to_next_business_day\x26quot;:false, \x26quot;failed_at\x26quot;:null, \x26quot;fee\x26quot;:0, \x26quot;finished_at\x26quot;:null, \x26quot;id\x26quot;:\x26quot;05e2950b-ff0c-4b8f-aa5f-7055bb8bc6f1\x26quot;, \x26quot;refund_reason_code\x26quot;:null, \x26quot;refund_reason_description\x26quot;:null, \x26quot;refunded_at\x26quot;:null, \x26quot;rejected_at\x26quot;:null, \x26quot;rejected_by\x26quot;:null, \x26quot;scheduled_to_effective\x26quot;:null, \x26quot;scheduled_to_requested\x26quot;:null, \x26quot;settled_at\x26quot;:null, \x26quot;status\x26quot;:\x26quot;APPROVED\x26quot;, \x26quot;target\x26quot;:{ \x26quot;account\x26quot;:{ \x26quot;account_code\x26quot;:\x26quot;1241441\x26quot;, \x26quot;branch_code\x26quot;:\x26quot;1241\x26quot;, \x26quot;institution_code\x26quot;:\x26quot;00000000\x26quot;, \x26quot;institution_name\x26quot;:\x26quot;Banco do Brasil S.A.\x26quot; }, \x26quot;entity\x26quot;:{ \x26quot;cpf\x26quot;:\x26quot;37818425098\x26quot;, \x26quot;name\x26quot;:\x26quot;fulano novo\x26quot; } } } Homologando sua Integração Uma vez que o seu sistema que integra na API do Stone OpenBank está pronto e testado em Sandbox, você vai passar pelo processo de Homologação antes de ir para Produção.\nEsse processo consiste em executar todas as ações que a sua Aplicação tem autorização para fazer, numa sequência definida e com o acompanhamento da equipe da Stone. Esse processo visa garantir que sua Aplicação vai funcionar conforme o esperado e que possui acesso a todos os recursos necessários.\nQualquer problema encontrado durante esta fase deve ser resolvido antes de prosseguir com a subida para Produção.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/integracao\/testando-a-api\/"},{value:"Paginação",label:"<p>Nossas APIs usam um padrão de paginação por cursor. O retorno possui o seguinte formato:\n{ cursor: { after: string | null, before: string | null, limit: number }, data: Array\x26amp;lt;Data\x26amp;gt; } Como funciona: deve-se informar o limite de items para a paginação, passando o parâmetro ?limit=10. Na resposta dessa query, será retornado as hashs referente ao cursor no momento da resposta, ex.:\n{ cursor: { after: ASsa987fqw, before: null, limit: 10 }, data: Array\x26amp;lt;Data\x26amp;gt; } Assim, caso queira consultar o próximo cursor, acrescentar o parâmetro after na chamada: ?limit=10\x26amp;after=ASsa987fqw, será retornado a próxima paginação.\n</p>",url:"https:\/\/stone-co.github.io\/referencia-da-api\/stone-openbank\/paginacao\/"},{value:"Elixir",label:"<p>Acesse aqui a SDK.\nLinguagem: Elixir\nPrincipais funcionalidades disponíveis:\n Autenticação  Token JWT de autenticação Chamada de autenticação   Consentimento  Token JWT para consentimento Chama de consentimento   Transferências internas  Dry-run Criação   Transferências externas  Dry-run Criação   Pagamentos  Dry-run Criação   Webhooks  Descriptografia Validação de assinatura Stone   Contas  listagem de contas pagamentos que a aplicação tem acesso.    </p>",url:"https:\/\/stone-co.github.io\/sdks\/elixir\/"},{value:"Consentimento",label:"<p>Como obter acesso às contas de pagamento.  Consentimento é o processo em que a usuária dona da conta acessa um link gerado pela Aplicação Parceira e através dele permite o acesso a suas informações e a sua conta de pagamento.\nToda vez que uma Aplicação faz um pedido de consentimento a uma usuária o mesmo englobará todos os escopos que aquela aplicação tem. No fluxo serão listados para a usuária todos os escopos que estão sendo solicitados.\nFluxo de consentimento Para realizar esse processo, a usuária precisa receber do sistema do parceiro um link que a direcione para uma página da Stone. Nessa página a usuária poderá escolher a quais contas de pagamento ela deseja conceder o acesso. Será necessário que o sistema do parceiro gere esse link, como descrito abaixo. O tempo de expiração do link deve ser de no máximo duas horas.\nCaso a usuária não acesse o link disponibilizado dentro de seu intervalo de tempo de vida, ele irá expirar. Nesse caso não haverá a concessão do acesso e não será mais possível obtê-la através desse mesmo link, precisando gerar um novo.\nTambém é possível que a usuária acesse o link mas não conceda o acesso, ao escolher a opção Ignorar. Nesse caso a usuária será redirecionada para uma página do sistema do parceiro e não será possível para ele operar na conta da usuária.\nHavendo a concessão de acesso, a usuária será redirecionada para uma página da Aplicação e o parceiro obterá as autorizações necessárias para operar na conta.\nO sistema do parceiro será informado do ocorrido para cada um desses três casos.\nObserve que no fluxo atual é preciso que o parceiro direcione sua cliente a abrir uma Conta Stone. Quando a usuária estiver com sua Conta Stone aberta, o parceiro poderá realizar o processo de consentimento para operar em sua conta.\nGerando um link de consentimento Uma vez cadastrada e autenticada a Aplicação, a primeira funcionalidade a ser desenvolvida é o consentimento.\nPara dar início ao processo de consentimento, basta que a desenvolvedora gere um link com os parâmetros necessários conforme especificados abaixo. Toda a interação com a usuária será gerida pela nossa plataforma.\nApós o link ser gerado, ele deverá ser enviado pela Aplicação Parceira para a usuária. Isso pode ser feito por e-mail ou dentro da própria Aplicação como, por exemplo, através de um botão.\nO link de consentimento deve conter três parâmetros:  client_id: o ClientID recebido pela desenvolvedora pós-cadastro; type: no caso, será sempre o valor \x26ldquo;consent\x26rdquo;; jwt: será um token gerado localmente pela desenvolvedora com a mesma chave privada e algoritmo que ela usa para se autenticar. Mais detalhes abaixo.  Com estes parâmetros, basta gerar um link no seguinte formato (por ambiente):\n Sandbox: https:\/\/sandbox-accounts.openbank.stone.com.br\/#\/consent?type=consent\x26amp;amp;client_id=CLIENT_ID\x26amp;amp;jwt=JWT Produção: https:\/\/accounts.openbank.stone.com.br\/#\/consent?type=consent\x26amp;amp;client_id=CLIENT_ID\x26amp;amp;jwt=JWT  Substituindo CLIENT_ID e JWT por seus respectivos valores.\nGerando o token Gerar um token JWT de consentimento é parecido com o processo de gerar um token de autenticação. O token deve conter os claims:\n   Campo Descrição Tipo     Obrigatórios     type Será sempre \x26ldquo;consent\x26rdquo; neste caso. String   client_id Será o ClientID da Aplicação Parceira. String   redirect_uri A URI para redirecionamento após a ação da usuária. Esta URI foi informada previamente no cadastro da Aplicação Parceira. Caso seja enviada uma URI diferente, retornará erro. String   session_metadata Um objeto que contenha qualquer chave relevante para o parceiro identificar a sessão da usuária. Este valor estará presente na URI de redirecionamento e não pode ser nulo ou um mapa vazio. Objeto   iss Usar o client_id da Aplicação. String   iat Momento em que o token foi gerado. É um timestamp UTC. Exemplo: \x26quot;iat\x26quot;: 1542235633. Int   aud accounts-hubid@openbank.stone.com.br String   jti Identificador único do token gerado. Normalmente se utiliza um UUID. String   nbf É o momento em que o token passa a ser válido. Na maioria dos casos terá o mesmo valor que iat (issued at) pois queremos que ele esteja válido logo a partir do momento de geração. Int   exp Momento de expiração do token em segundos desde o início da era UNIX (1970). É um timestamp UTC e não pode ser maior que 2 horas. Exemplo: \\\x26quot;exp\\\x26quot;: 1542235633 Int    Observe que é preciso assinar o token JWT com a chave privada da aplicação e o algoritmo RS256, assim como é feito para o token de autenticação. Dessa forma, neste token também é preciso incluir um header com as informações sobre o algoritmo de criptografia utilizado, entre outros metadados, como um id da chave utilizada. Por exemplo:\n{ \x26quot;alg\x26quot;: \x26quot;RS256\x26quot;, \x26quot;typ\x26quot;: \x26quot;JWT\x26quot; }  Apesar do ClientID ser o disponibilizado pela Stone ao parceiro no Cadastro da Aplicação e o mesmo utilizado para montar o token de autenticação, observe que o nome do campo para esse token é client_id, diferente de clientId utilizado no token de autenticação.\n Assim, um exemplo de claims para este token seria:\n{ \x26quot;type\x26quot;: \x26quot;consent\x26quot;, \x26quot;client_id\x26quot;: \x26quot;MY CLIENT ID\x26quot;, \x26quot;iss\x26quot;: \x26quot;MY CLIENT ID\x26quot;, \x26quot;redirect_uri\x26quot;: \x26quot;https:\/\/mypreviouslyregistereduri.com\x26quot;, \x26quot;session_metadata\x26quot;: { \x26quot;user_session\x26quot;: \x26quot;xxxxxxxxxxxxxxxxxxxxx\x26quot;, }, \x26quot;iat\x26quot;: 1542235633, \x26quot;nbf\x26quot;: 1542235633, \x26quot;exp\x26quot;: 1549069563, \x26quot;jti\x26quot;: \x26quot;41e8aa9f-bb9c-4fd2-9953-2595dbbd5a83\x26quot;, \x26quot;aud\x26quot;: \x26quot;accounts-hubid@openbank.stone.com.br\x26quot; } Redirect callback A usuária irá visualizar as permissões às quais a Aplicação Parceira está pedindo acesso e poderá optar por ignorar ou consentir o acesso.\nEm ambos os casos, faremos um redirecionamento para a URI cadastrada no token. Acrescentaremos na URI os seguintes campos:\n os valores de session_metadata passados no token; a chave \x26ldquo;consent_result\x26rdquo; que poderá ter o valor de \x26ldquo;ignored\x26rdquo; ou \x26ldquo;approved\x26rdquo;; se o resultado for \x26ldquo;approved\x26rdquo;, também passaremos o campo \x26ldquo;resource_id\x26rdquo; com o identificador do resource ao qual o consentimento foi dado.  Assim, fica fácil para a desenvolvedora prover uma experiência para ambos os casos: basta validar estes campos!\nFluxo para a usuária Para uma integração Open Banking de sucesso é essencial considerar a experiência da usuária, principalmente em fluxos de redirecionamento como para o consentimento. No início desta sessão detalhamos o passo a passo desse procedimento; neste tópico vamos exemplificar algumas das principais telas utilizadas.\nAo seguir o link gerado pela desenvolvedora, a usuária será redirecionada para uma página da Stone. Solicitaremos à dona o acesso à sua conta, explicitando quais permissões ela está concedendo à aplicação parceira. Podemos observar abaixo um exemplo de tela em que isso ocorre.\n  Caso a usuária opte por conceder o acesso no botão Permitir e ocorra tudo bem, será exibida uma tela de sucesso, confirmando que a permissão foi concedida. Podemos observar um exemplo dessa tela abaixo.\nAo clicar no botão Ok, entendi ela será redirecionada para uma página da aplicação parceira, cujo endereço foi definido no cadastro da aplicação, em Redirect URI.\n  É possível que ocorra também um caso em que a usuária já concedeu o acesso à aplicação parceira. Neste caso, a usuária irá visualizar uma tela como o seguinte exemplo.\nAssim como no caso anterior, ela também será redirecionada para uma página da aplicação parceira ao clicar no botão Ok, entendi.\n  </p>",url:"https:\/\/stone-co.github.io\/guias\/integracao\/consentimento\/"},{value:"Valores Financeiros",label:"<p>Todos os valores na API serão sempre inteiros e expressos em centavos de Reais.\nAssim, o valor de um real (R$1,00) ficaria: 100.\n</p>",url:"https:\/\/stone-co.github.io\/referencia-da-api\/stone-openbank\/valores-financeiros\/"},{value:"FAQ",label:"<p> Qual a diferença entre o status failed e refunded?    Refunded é o status correspondente a uma devolução. Ou seja, chegamos a efetuar a operação e enviá-la para a instituição de destino e a mesma foi devolvida. As operações que podem sofrer devolução são transferências externas e pagamentos. É possivel ver no extrato tanto a operação criada, quando sua devolução. Failed é o status correspondente a uma falha. Ou seja, na hora de processarmos a operação internamente tivemos alguma falha. As operações que podem sofrer uma falha são: transferências externas, transferências internas e pagamentos. Essas operações não podem ser vistas no extrato porque não chegaram a de fato gerar uma movimentação.   Quando a taxa é devolvida de uma transação refunded? E no caso de uma transação failed?    Quando a transação passa para o status refunded a taxa referente aquela movimentação é devolvida imeditamente para a conta. No caso de uma transação que falha no processamento a taxa nem chega a ser cobrada da usuária.   A partir de que momento é possível pedir consent para uma conta?    O consentimento é dado por um sujeito (usuária, a uma aplicação, sobre um determinado recurso (conta pagamento). Assim só é possível que o consentimento seja dado após a abertura da conta. Além disso, pelo consentimento ser um fluxo logado é preciso que a usuária tenha ao menos criado sua senha de acesso.   Em quanto tempo uma TED chega a conta de destino?    Isso depende diretamente do tempo de processamento da instituição de destido, sendo assim não é possível identificar o momento exato que a TED entra na outra conta. Mas, apesar de assíncrono, é possível acompanhar pelos webhooks o momento que iniciamos o processamento interno (cash_out_external_transfer_execution_started) e que finalizamos o envio (cash_out_external_transfer_finished) para a outra instituição.   Para que instituições é possível fazer TEDs?    É possível fazer TEDs para todas as intituições participantes Sistema de Transferência de Reservas (STR) do Sitema de Pagamentos Brasileiro (SPB). Você pode ver a lista completa dos participantes do STR no site do Banco Central ou na nossa API de instituições.   Quais adquirentes e subadquirentes pagam na Conta Stone?    Sim! Hoje é possível cadastrar sua Conta Stone para receber pagamentos da: Acqio, Bin, Cielo, GetNet, Gympass, Ifood, Moip, PagSeguro, PicPay, Stelo, Stone e SumUp.   Que bandeiras e vouchers posso receber na Conta Stone?    Hoje é possível direcionar os recebíveis das seguintes bandeiras\/vuchers para sua Conta Stone: Visa, Mastercard, Elo, Amex, Hiper, Cabal Sodexo, VR, Ticket, Green Card, Coopecard, Verocard e Ben.   </p>",url:"https:\/\/stone-co.github.io\/faq\/"},{value:"Aprovação",label:"<p>Como a dona da conta permite que uma transação criada pelo parceiro seja realizada.  A Aprovação de uma Transação tem como objetivo garantir que toda movimentação financeira de saída de uma conta seja feita somente por uma usuária devidamente autorizada. É um procedimento em que a usuária que já concedeu o consentimento é notificada da criação de uma transação e direcionada para uma página onde é possível visualizar todas as transações criadas pelo parceiro. Nessa página é possível aprovar ou rejeitar uma transação, possibilitando ou impedindo sua realização. É importante lembrar que apenas Aplicativos com consentimento podem criar transações.\nNo Open Banking, o parceiro pode criar uma transação na conta da usuária, mas esta só será efetuada se houver a aprovação da usuária dona da conta. Esse procedimento assegura à dona da conta de que não haverá movimentação de seu dinheiro sem sua permissão, além de proteger a aplicação de eventuais erros, ataques ou bugs que iniciem transações não desejadas pela usuária.\nO Aprovador é um aplicativo utilizado pela usuária para realizar a autorização de transações criadas pelo parceiro. Além disso, através do aplicativo é possível manter um histórico de movimentação de saída de uma conta. Nesse histórico é possível visualizar os valores movimentados, o destino das movimentações e a usuária que autorizou as transações. É possível também utilizá-lo para realizar aprovações em lote, ou seja, aprovar um grande número de transações pendentes ao mesmo tempo.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/integracao\/aprovacao\/"},{value:"Códigos De Resposta",label:"<p>Nossa API usa como retorno os códigos HTTP padrão para indicar tanto o sucesso de uma requisição, quanto para indicar falha. Pode-se utilizar a tabela abaixo como referência:\n   Código Significado     200 Tudo ocorreu como deveria e sua requisição foi processada com sucesso.   201 A requisição foi bem sucedida e um novo recurso foi criado como resultado.   202 Processo iniciado com sucesso.   204 Bem sucedido, sem conteúdo de resposta.   400 Algum parâmetro obrigatório não foi passado ou os parâmetros passados não estão corretos.   401 Falta de autenticação para acessar este endpoint.   403 Falta de autorização para acessar este endpoint.   404 Endpoint não encontrado, revise a URL passada.   409 A solicitação atual conflitou com o recurso que está no servidor.   422 Entidade não processável. Não é uma ação válida para os dados enviados.   500 Erro interno do servidor, tente sua requisição novamente.    Identificador da Requisição O cabeçalho da resposta sempre inclui um campo identificador da requisição, chamado x-request-id. Este valor deve ser enviado sempre que precisar de suporte, já que ele nos permite encontrar a chamada no nosso sistema e verificar o que possa ter dado errado.\n </p>",url:"https:\/\/stone-co.github.io\/referencia-da-api\/stone-openbank\/codigos-de-resposta\/"},{value:"Go",label:"<p>Acesse aqui a SDK.\nDesenvolvido por: Stone\nLinguagem: Go\nPrincipais funcionalidades disponíveis:\n Autenticação  Token JWT de autenticação Chamada de autenticação   Consentimento  Token JWT para consentimento Chama de consentimento   Transferências internas  Dry-run Criação Listar transações de uma conta Retornar uma transação   Transferências externas  Dry-run Criação Listar transações de uma conta Retornar uma transação   Boletos proposta  emissão listar boletos de uma conta retornar um boleto   Webhooks  Descriptografia Validação de assinatura Stone   Contas  listagem de contas pagamentos que a aplicação tem acesso.    </p>",url:"https:\/\/stone-co.github.io\/sdks\/go\/"},{value:"Webhooks",label:"<p>A ocorrência de certos eventos pode ser importante para iniciar um processamento na plataforma do parceiro. Por isso, utilizamos webhooks para notificá-lo da ocorrência destes eventos.\nPara sua utilização, é preciso que sua aplicação tenha cadastrada no formulário a URI para a qual enviaremos um POST com os dados do evento. O parceiro deverá se preparar para lidar com cada evento de forma adequada.\nRealizamos 50 tentativas de envio dos webhooks.\nOs eventos que geram notificações são:    Tipo de evento Descrição     barcode_payment_invoice_created Representa a criação\/emissão de um boleto.   barcode_payment_invoice_registered Representa o registro de um boleto.   barcode_payment_invoice_payment_promissed Representa que o pagamento do boleto foi acolhido em alguma instituição.   barcode_payment_invoice_settled Representa a entrada do valor do boleto na conta do beneficiário.   cash_in_barcode_payment Representa o recebimento do pagamento de um boleto.   cash_in_card_payment Representa o recebimento de pagamentos de cartão de crédito, cartão de débito ou de antecipação de pagamentos.   cash_in_payment_refund Representa o reembolso de um pagamento mal sucedido.   cash_in_internal_transfer Representa o recebimento de uma transferência interna.   cash_in_external_transfer Representa o recebimento de uma transferência externa.   cash_in_external_transfer_refund Representa o reembolso de uma transferência externa mal sucedida.   cash_out_internal_transfer Representa a criação de uma transferência interna.   cash_out_internal_transfer_failed Representa a falha na criação de uma transferência interna.   cash_out_internal_transfer_scheduled Representa o agendamento de uma transferência interna.   cash_out_internal_transfer_scheduled_failed Representa a falha no agendamento de uma transferência interna.   cash_out_internal_transfer_approved Representa a aprovação de uma transferência interna.   cash_out_internal_transfer_cancelled Representa o cancelamento de uma transferência interna.   cash_out_internal_transfer_rejected Representa a rejeição de uma transferência interna.   cash_out_internal_transfer_finished Representa a finalização de uma transferência interna.   cash_out_internal_transfer_expired Representa a expiração de uma transferência interna.   cash_out_external_transfer Representa a criação de uma transferência externa.   cash_out_external_transfer_failed Representa a falha na criação de uma transferência externa.   cash_out_external_transfer_scheduled Representa o agendamento de uma transferência externa.   cash_out_external_transfer_scheduled_failed Representa a falha no agendamento de uma transferência externa.   cash_out_external_transfer_approved Representa a aprovação de uma transferência externa.   cash_out_external_transfer_cancelled Representa o cancelamento de uma transferência externa.   cash_out_external_transfer_rejected Representa a rejeição de uma transferência externa.   cash_out_external_transfer_finished Representa a finalização de uma transferência externa.   cash_out_external_transfer_expired Representa a expiração de uma transferência externa.   cash_out_external_transfer_execution_started Representa o início da execução de uma transferência externa.   cash_out_payment Representa a criação de um pagamento.   cash_out_payment_failed Representa a falha na criação de um pagamento.   cash_out_payment_scheduled Representa o agendamento de um pagamento.   cash_out_payment_scheduled_failed Representa a falha no agendamento de um pagamento.   cash_out_payment_approved Representa a aprovação de um pagamento.   cash_out_payment_cancelled Representa o cancelamento de um pagamento.   cash_out_payment_rejected Representa a rejeição de um pagamento.   cash_out_payment_finished Representa a finalização de um pagamento.   cash_out_payment_expired Representa a expiração de um pagamento.   cash_out_payment_execution_started Representa o início da execução de um pagamento.   consent_requested Representa a confirmação do pedido de consentimento por parte do user.    O header das notificações segue a seguinte estrutura: x-stone-webhook-event-id: \x26quot;930bbd6d-0c7a-4fe4-8b50-4b82a20cb847\x26quot; x-stone-webhook-event-type: \x26quot;cash_out_internal_transfer\x26quot; O payload da notificações segue a seguinte estrutura:    Campo Descrição     env Especifica de qual ambiente partiu o evento. Valores possíveis: sandbox ou production.   event_type Especifica qual tipo de evento disparou a notificação. Veja os valores possíveis aqui.   id É o identificador da notificação.   event_notified_at É a hora em que a notificação está sendo enviada.   event_happened_at É a hora em que o evento ocorreu.   target_data Objeto com as informações detalhadas do recurso que gerou o evento. Apesar de ter campo variáveis sempre conterá o campo account_id.   target_detail_uri É o endereço onde se pode consultar os detalhes do recurso.   target_id É o identificador do recurso que gerou o evento.   target_statement_uri É o endereço da entrada no extrato referente ao recurso.   target_type É o tipo do recurso.    Inclusão de campos A implementação não deve ser strict no parser do payload. Ao longo do tempo os payloads podem sofrer a inclusão de campos.\n Exemplo: { \x26quot;env\x26quot;:\x26quot;sandbox\x26quot;, \x26quot;event_type\x26quot;:\x26quot;cash_in_internal_transfer\x26quot;, \x26quot;event_happened_at\x26quot;:\x26quot;2020-05-13T14:58:15Z\x26quot;, \x26quot;event_notified_at\x26quot;:\x26quot;2020-05-13T14:58:15Z\x26quot;, \x26quot;iat\x26quot;:1589381895, \x26quot;id\x26quot;:null, \x26quot;jti\x26quot;:\x26quot;2o79sqemde14mv76eo00jsc3\x26quot;, \x26quot;nbf\x26quot;:1589381895, \x26quot;target_data\x26quot;:{ \x26quot;account_id\x26quot;:\x26quot;09c016b2-876a-450a-9f40-316f8e2f8778\x26quot;, \x26quot;amount\x26quot;:1, \x26quot;balance_after\x26quot;:null, \x26quot;balance_before\x26quot;:null, \x26quot;counter_party\x26quot;:{ \x26quot;account\x26quot;:{ \x26quot;account_code\x26quot;:\x26quot;841412\x26quot;, \x26quot;branch_code\x26quot;:\x26quot;1\x26quot;, \x26quot;institution\x26quot;:\x26quot;16501555\x26quot;, \x26quot;institution_name\x26quot;:\x26quot;Stone Pagamentos S.A.\x26quot; }, \x26quot;entity\x26quot;:{ \x26quot;name\x26quot;:\x26quot;Loja Da Maria\x26quot; } }, \x26quot;created_at\x26quot;:\x26quot;2020-05-13T14:58:15Z\x26quot;, \x26quot;description\x26quot;:\x26quot;\x26quot;, \x26quot;id\x26quot;:\x26quot;54abd61c-3b18-401c-9816-951cbe135149\x26quot;, \x26quot;operation\x26quot;:\x26quot;credit\x26quot;, \x26quot;status\x26quot;:\x26quot;FINISHED\x26quot;, \x26quot;type\x26quot;:\x26quot;internal\x26quot; }, \x26quot;target_detail_uri\x26quot;:null, \x26quot;target_id\x26quot;:null, \x26quot;target_statement_uri\x26quot;:\x26quot;https:\/\/sandbox-api.openbank.stone.com.br\/api\/v1\/statement\/entries\/54abd61c-3b18-401c-9816-951cbe135149\x26quot;, \x26quot;target_type\x26quot;:\x26quot;internal_transfer\x26quot; } Trabalhando com Webhooks Webhooks Seguros Nossa API envia webhooks de forma segura para evitar que eles sejam abertos e\/ou alterados. Isso é feito em duas etapas:\n Assinatura do conteúdo usando uma das nossas chaves públicas. Ciframento do resultado usando a chave pública do destinatário.  Como eu posso abrir de forma segura o conteúdo de um webhook? Para poder visualizar o conteúdo de um webhook é necessário fazer o caminho inverso:\n Usar sua chave privada para poder decifrar o conteúdo. O resultado é um token JWT assinado com a nossa chave; Verificar a assinatura do token com a nossa chave pública.  1 - Decifrando o conteúdo do webhook O webhook irá chegar com um payload parecido com esse:\n{ \x26quot;encrypted_body\x26quot;: \x26quot;xxxxxxxxxxxxxx conteúdo cifrado\x26quot; } O valor do campo \x26ldquo;encrypted_body\x26rdquo; é um token no formato JWE (JSON Web Encryption) compacto. Esse formato é um padrão e várias linguagens possuem bibliotecas prontas para ele.\nO algoritmo utilizado é: RSA-OAEP-256 com A256GCM. Para decifrar o conteúdo é necessário uma biblioteca que suporte estes algoritmos como:\n JavaScript Java Erlang\/Elixir Go  A chave a ser utilizada tem que ser a chave privada par da chave pública usada na autenticação da aplicação.\n2 - Verificando a assinatura do conteúdo do webhook Até este momento deciframos apenas um conteúdo que pode ser gerado por qualquer um que tenha acesso a chave pública da aplicação.\nNós utilizamos a assinatura do conteúdo em token JWS (JSON Web Signing) compacto como uma outra camada de verificação de segurança no conteúdo do webhook.\nEsse token possui em seus \x26ldquo;claims\x26rdquo; (alegações) o conteúdo do webhook. Para garantir que ele foi gerado pela Stone, você deve validar a assinatura dele consultando nossas chaves públicas de assinatura.\nAs chaves públicas da Stone estão publicadas aqui.\nRepare que cada chave possui um kid (key ID) e um use (sig ou enc). O token JWS possui um header que diz qual é o id da chave usada para assiná-lo. Assim, é necessário, em primeiro lugar, garantir que o token foi assinado com uma chave que está publicada pela Stone.\nO algoritmo que usamos será sempre RS256. Há uma lista de bibliotecas que tratam de assinatura de token em jwt.io.\nSegurança É importante seguir os dois passos aqui: tanto decifrar quanto verificar a assinatura. Isso irá garantir que não apenas geramos algo que não pode ser lido por alguém que não possui a chave pública quanto que nosso conteúdo foi assinado pela Stone.\nTambém aconselhamos cuidado na configuração do cliente que irá consultar as nossas chaves. Certifique-se que ele não está vulnerável a servidores intermediários propositalmente mal configurados. Um exemplo comum é um servidor configurado para protocolos conhecidamente falhos.\nSempre que em dúvida, consulte nossa API com os IDs dos dados no conteúdo do webhook.\nMais informações sobre JavaScript Object Signing and Encryption, como JWTs, JWEs, JWSs, aqui.\n</p>",url:"https:\/\/stone-co.github.io\/guias\/integracao\/webhooks\/"},{value:"Mensagens De Erro",label:"<p>Nossos endpoints seguem um padrão de mensagens. Toda mensagem de erro, por exemplo, seguirá o modelo \x26ldquo;srn:error:xxx\x26quot; e um código HTTP apropriado para a falha.\nPor exemplo:\n{ \x26quot;type\x26quot;: \x26quot;srn:error:target_account_not_found\x26quot; } Alguns endpoints têm uma resposta mais completa, entregando a mensagem de erro mencionada e mais detalhes.\nPor exemplo:\n{ \x26quot;errors\x26quot;: [ { \x26quot;error\x26quot;: \x26quot;is invalid\x26quot;, \x26quot;path\x26quot;: [ \x26quot;tax_id\x26quot; ] } ], \x26quot;type\x26quot;: \x26quot;srn:error:bad_request\x26quot; } </p>",url:"https:\/\/stone-co.github.io\/referencia-da-api\/stone-openbank\/mensagens-de-erro\/"},{value:".Net",label:"<p>Acesse aqui a SDK.\nLinguagem: .Net Principais funcionalidades disponíveis:\n Autenticação  Token JWT de autenticação    </p>",url:"https:\/\/stone-co.github.io\/sdks\/dotnet\/"},{value:"Stone OpenBank",label:"<p></p>",url:"https:\/\/stone-co.github.io\/"},{value:"Categories",label:"<p></p>",url:"https:\/\/stone-co.github.io\/categories\/"},{value:"Tags",label:"<p></p>",url:"https:\/\/stone-co.github.io\/tags\/"},];$("#search").autocomplete({source:projects}).data("ui-autocomplete")._renderItem=function(ul,item){return $("<li>").append("<a href="+item.url+" + \" &quot;\" +  >"+item.value+"</a>"+item.label).appendTo(ul);};});</script></div></div></div></div></header><section class=section><div class=container><div class="row justify-content-center"><div class="col-12 text-center"><h2 class=section-title></h2></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://stone-co.github.io/referencia-da-api/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-panel icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Referência da API</h3><p class=mb-0>Conheça os endpoints da nossa API e seus contratos.</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://stone-co.github.io/guias/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-direction-alt icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Guias</h3><p class=mb-0>Todos os processos, requerimentos e melhores práticas para a utilização de nossa API.</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://stone-co.github.io/parceiros/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-heart icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Parceiros</h3><p class=mb-0>Descrição Parceiros</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://stone-co.github.io/sdks/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-support icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">SDKs</h3><p class=mb-0>Descrição SDKs</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://stone-co.github.io/faq/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-help icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">FAQ</h3><p class=mb-0>Tire suas dúvidas aqui!</p></a></div></div></div></section><section><div class=container><div class=row><div class=col-12><div class="section px-3 bg-white shadow text-center"><h2 class=mb-4>Quer entender mais dos nossos modelos de parceria?</h2><p class=mb-4>Sem problemas, fale com nosso time comercial!</p><a href="https://app.pipefy.com/public/form/Qz4ptt_W?origem_do_lead=Formul%C3%A1rio%20comercial%20documenta%C3%A7%C3%A3o" class="btn btn-primary">Entrar em contato</a></div></div></div></div></section><footer class="section pb-4"><div class=container><div class="row align-items-center"><div class="col-md-8 text-md-left text-center"><p class="mb-md-0 mb-4"></p></div><div class="col-md-4 text-md-right text-center"><ul class=list-inline><li class=list-inline-item><a class="text-color d-inline-block p-2" href=#><i class=ti-world></i></a></li><li class=list-inline-item><a class="text-color d-inline-block p-2" href=#><i class=ti-github></i></a></li></ul></div></div></div></footer><script src=https://stone-co.github.io/js/script.min.js></script></body></html>